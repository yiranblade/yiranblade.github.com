<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>yiranblade&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="yiranblade&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="yiranblade&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yiranblade&#39;s blog">
  
    <link rel="alternate" href="/atom.xml" title="yiranblade&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author"></h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>11</strong><br>文章</div></a>
      <a href="/categories"><div><strong>3</strong><br>分类</div></a>
      <a href="/tags"><div><strong>9</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-go版本shadowsocks源码-(二)" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/28/go版本shadowsocks源码-(二)/" class="article-date">
  <time class="post-time" datetime="2019-03-28T12:29:39.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br>
    <span class="post-day">28</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/28/go版本shadowsocks源码-(二)/">go版本shadowsocks源码(二)</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/源码/">源码</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本节来分析下，在上次开启本地服务等待连接后，handleConnection()函数是怎样处理拿到的请求的。</p>
<h2 id="socks5协议客户端连接要求"><a href="#socks5协议客户端连接要求" class="headerlink" title="socks5协议客户端连接要求"></a>socks5协议客户端连接要求</h2><p>在看具体的代码之前，我们首先来看看官方标准中是如何规定本地与客户端之间的交互的。<br>协议规定当客户端连到服务器后，然后就发送请求来协商版本和认证方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">VER</th>
<th>NMETHODS</th>
<th>METHODS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td>1</td>
<td>1 to 255</td>
<td></td>
</tr>
</tbody>
</table>
<p>其中ver表示协议版本（固定长度为一个字节），nmethods表示第三个字段的长度（即有几种认证方法），methods表示客户端支持的验证方式，长度1-255字节。<br>支持的验证方式官方制定了以下几种：</p>
<ul>
<li>0x00:NO AUTHENTICATION REQUIRED（不需要验证）</li>
<li>0x01:GSSAPI (通用安全服务应用程序接口)</li>
<li>0x02:USERNAME/PASSWD(用户名密码)</li>
<li>0x03:IANA ASSIGNED(至 0x’7F’ IANA 分配)</li>
<li>0x80:RESERVED FOR PRIVATE METHODS(至 0x’FE’ 私人方法保留)</li>
<li>0xff:NO ACCEPTABLE METHODS(没有可接受的方法)</li>
</ul>
<p>当服务端收到客户端的验证信息后，就要回应客户端提供哪种验证方式的信息。回应格式如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">VER</th>
<th>METHOD</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="handleConnect函数"><a href="#handleConnect函数" class="headerlink" title="handleConnect函数"></a>handleConnect函数</h2><p>现在我们来看hendleConnect函数是如何处理连接的：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> debug &#123;</span><br><span class="line">		debug.Printf(<span class="string">"socks connect from %s\n"</span>, conn.RemoteAddr().String())</span><br><span class="line">	&#125;</span><br><span class="line">	closed := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !closed &#123;</span><br><span class="line">			conn.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> err error = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> err = handShake(conn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"socks handshake:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	rawaddr, addr, err := getRequest(conn)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"error getting request:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Sending connection established message immediately to client.</span></span><br><span class="line">	<span class="comment">// This some round trip time for creating socks connection with the client.</span></span><br><span class="line">	<span class="comment">// But if connection failed, the client will get connection reset error.</span></span><br><span class="line">	_, err = conn.Write([]<span class="keyword">byte</span>&#123;<span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x43</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		debug.Println(<span class="string">"send connection confirmation:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	remote, err := createServerConn(rawaddr, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(servers.srvCipher) &gt; <span class="number">1</span> &#123;</span><br><span class="line">			log.Println(<span class="string">"Failed connect to all available shadowsocks server"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !closed &#123;</span><br><span class="line">			remote.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> ss.PipeThenClose(conn, remote, <span class="literal">nil</span>)</span><br><span class="line">	ss.PipeThenClose(remote, conn, <span class="literal">nil</span>)</span><br><span class="line">	closed = <span class="literal">true</span></span><br><span class="line">	debug.Println(<span class="string">"closed connection to"</span>, addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先我们可以看到在代码13行-16行，对连接进行请求的协商，也就是第一部分介绍的交互协商认证的流程。<br><strong>handShake代码如下</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handShake</span><span class="params">(conn net.Conn)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		idVer     = <span class="number">0</span></span><br><span class="line">		idNmethod = <span class="number">1</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">258</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">	ss.SetReadTimeout(conn)</span><br><span class="line">	<span class="keyword">if</span> n, err = io.ReadAtLeast(conn, buf, idNmethod+<span class="number">1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> buf[idVer] != socksVer5 &#123;</span><br><span class="line">		<span class="keyword">return</span> errVer</span><br><span class="line">	&#125;</span><br><span class="line">	nmethod := <span class="keyword">int</span>(buf[idNmethod])</span><br><span class="line">	msgLen := nmethod + <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> n == msgLen &#123; </span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> n &lt; msgLen &#123; </span><br><span class="line">		<span class="keyword">if</span> _, err = io.ReadFull(conn, buf[n:msgLen]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> errAuthExtraData</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = conn.Write([]<span class="keyword">byte</span>&#123;socksVer5, <span class="number">0</span>&#125;)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码11行读取了本地客户端发来的版本信息以及认证方法信息，如果协议版本不是socks5则立马返回。由于socks规定的字段ver与nmethods都是两个字节所以最后一个字段加上2个字节就是需要读取的信息总长度，最后第27行代码返回给客户端协议版本信息与选择的方法（此处不需要验证，所以传递0）。</p>
<hr>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rawaddr, addr, err := getRequest(conn)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"error getting request:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>然后让我们把视角在回到handleConnection函数，在完成handshake的认证后客户端会向local发送一个带有目的地址和端口的请求包，由request函数完成获取操作。以下是发送的包内容：<br>|VER|CMD|RSV|ATYP|DST.ADDR|DST.PORT|<br>:-:|:-:|:-:|<br>|1|1|0x00|1|Variable|2|</p>
<ul>
<li>VER:socks的版本</li>
<li>CMD:代表客户端请求的类型，值长度1个字节，有三种类型：<ul>
<li>Connect:0x01</li>
<li>Bind:0x02</li>
<li>UDP:0x03</li>
</ul>
</li>
<li>RSV:保留字段，默认0x00，长度1个字节</li>
<li>ATYP:代表请求的远程服务器地址类型，长度1个字节，三种类型：<ul>
<li>IPV4:0X01</li>
<li>IPV6:0X04</li>
<li>DOMAINNAME:0x03</li>
</ul>
</li>
<li>DST.ADDR:代表远程服务器的地址，根据ATYP进行解析，值长度不定</li>
<li>DST.PORT:代表远程服务器的端口，值长度2个字节</li>
</ul>
<p>当loca接收到该信息，接下来应当向客户端返回一个结果，在代码中默认返回了success。如下所示：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, err = conn.Write([]<span class="keyword">byte</span>&#123;<span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x43</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		debug.Println(<span class="string">"send connection confirmation:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>当这些步骤完成后，接下来local端和server端建立连接。然后local负责把client的数据包加密后发送给ss-server。把收到的server数据包在发回给client。完成这些操作的函数就是PipeThenClose。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PipeThenClose</span><span class="params">(src, dst net.Conn, addTraffic <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> dst.Close()</span><br><span class="line">	buf := leakyBuf.Get()</span><br><span class="line">	<span class="keyword">defer</span> leakyBuf.Put(buf)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		SetReadTimeout(src)</span><br><span class="line">		n, err := src.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> addTraffic != <span class="literal">nil</span> &#123;</span><br><span class="line">			addTraffic(n)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// read may return EOF with n &gt; 0</span></span><br><span class="line">		<span class="comment">// should always process n &gt; 0 bytes before handling error</span></span><br><span class="line">		<span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Note: avoid overwrite err returned by Read.</span></span><br><span class="line">			<span class="keyword">if</span> _, err := dst.Write(buf[<span class="number">0</span>:n]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				Debug.Println(<span class="string">"write:"</span>, err)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// Always "use of closed network connection", but no easy way to</span></span><br><span class="line">			<span class="comment">// identify this specific error. So just leave the error along for now.</span></span><br><span class="line">			<span class="comment">// More info here: https://code.google.com/p/go/issues/detail?id=4373</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">				if bool(Debug) &amp;&amp; err != io.EOF &#123;</span></span><br><span class="line"><span class="comment">					Debug.Println("read:", err)</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在PipeThenClose代码中，其申请一块缓冲区然后不停的从src中读取数据，将数据转发到dst中。当然，读取的时候需要对数据进行解密，写的时候需要加密。解密加密操作分别由项目中的Conn负责，其重写了read与write函数，在read时会根据加密方法对数据进行解密。write时则会进行加密。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> ss.PipeThenClose(conn, remote, <span class="literal">nil</span>)</span><br><span class="line">	ss.PipeThenClose(remote, conn, <span class="literal">nil</span>)</span><br><span class="line">	closed = <span class="literal">true</span></span><br><span class="line">	debug.Println(<span class="string">"closed connection to"</span>, addr)</span><br></pre></td></tr></table></figure></p>
<p>在handleConnection代码的最后，其使用两个PipeThenClose，新开启的goroutine和本身的goroutine病发的从本地到远程、远程到本地的上下行进行数据传输。</p>
<p>综上，handleConnection函数整体流程如下：</p>
<div id="flowchart-0" class="flow-chart"></div>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>local端的代码到此就算结束了，由于是按照整体流程进行分析，有些过于细节的地方几句就略过去了，重点还是在学习整体的流程以及socks协议的使用。server端的思路其实和local端比较类似，除了没有local中握手（handShake）的步骤。整体看来这个还是不太复杂的，整体代码也就2000行左右。</p>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">stat=>start: 开始
op1=>operation: handShake认证协商操作
op2=>operation: getRequest获取目标地址
op3=>operation: createServerConn创建与远程服务端的连接
op4=>operation: 利用PipeThenClose将数据传输至服务端(并发操作)
op5=>operation: 利用PipeThenClose从远程服务端接收数据
ed=>end: 结束

stat->op1->op2->op3->op4->op5->ed</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/28/go版本shadowsocks源码-(二)/" data-id="cjtsn5jfz0000iu2xlh50nr2i" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go语言/">go语言</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-go版本shadowsocks源码-二" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/28/go版本shadowsocks源码-二/" class="article-date">
  <time class="post-time" datetime="2019-03-28T12:29:39.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br>
    <span class="post-day">28</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/28/go版本shadowsocks源码-二/">go版本shadowsocks源码(二)</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/源码/">源码</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本节来分析下，在上次开启本地服务等待连接后，handleConnection()函数是怎样处理拿到的请求的。</p>
<h2 id="socks5协议客户端连接要求"><a href="#socks5协议客户端连接要求" class="headerlink" title="socks5协议客户端连接要求"></a>socks5协议客户端连接要求</h2><p>在看具体的代码之前，我们首先来看看官方标准中是如何规定本地与客户端之间的交互的。<br>协议规定当客户端连到服务器后，然后就发送请求来协商版本和认证方法：<br>|VER|NMETHODS|METHODS|<br>:-:|:-:<br>|1|1|1 to 255|<br>其中ver表示协议版本（固定长度为一个字节），nmethods表示第三个字段的长度（即有几种认证方法），methods表示客户端支持的验证方式，长度1-255字节。<br>支持的验证方式官方制定了以下几种：</p>
<ul>
<li>0x00:NO AUTHENTICATION REQUIRED（不需要验证）</li>
<li>0x01:GSSAPI (通用安全服务应用程序接口)</li>
<li>0x02:USERNAME/PASSWD(用户名密码)</li>
<li>0x03:IANA ASSIGNED(至 0x’7F’ IANA 分配)</li>
<li>0x80:RESERVED FOR PRIVATE METHODS(至 0x’FE’ 私人方法保留)</li>
<li>0xff:NO ACCEPTABLE METHODS(没有可接受的方法)</li>
</ul>
<p>当服务端收到客户端的验证信息后，就要回应客户端提供哪种验证方式的信息。回应格式如下：<br>|VER|METHOD|<br>:-:|:-:<br>|1|1|</p>
<h2 id="handleConnect函数"><a href="#handleConnect函数" class="headerlink" title="handleConnect函数"></a>handleConnect函数</h2><p>现在我们来看hendleConnect函数是如何处理�连接的：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> debug &#123;</span><br><span class="line">		debug.Printf(<span class="string">"socks connect from %s\n"</span>, conn.RemoteAddr().String())</span><br><span class="line">	&#125;</span><br><span class="line">	closed := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !closed &#123;</span><br><span class="line">			conn.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> err error = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> err = handShake(conn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"socks handshake:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	rawaddr, addr, err := getRequest(conn)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"error getting request:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Sending connection established message immediately to client.</span></span><br><span class="line">	<span class="comment">// This some round trip time for creating socks connection with the client.</span></span><br><span class="line">	<span class="comment">// But if connection failed, the client will get connection reset error.</span></span><br><span class="line">	_, err = conn.Write([]<span class="keyword">byte</span>&#123;<span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x43</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		debug.Println(<span class="string">"send connection confirmation:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	remote, err := createServerConn(rawaddr, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(servers.srvCipher) &gt; <span class="number">1</span> &#123;</span><br><span class="line">			log.Println(<span class="string">"Failed connect to all available shadowsocks server"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !closed &#123;</span><br><span class="line">			remote.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> ss.PipeThenClose(conn, remote, <span class="literal">nil</span>)</span><br><span class="line">	ss.PipeThenClose(remote, conn, <span class="literal">nil</span>)</span><br><span class="line">	closed = <span class="literal">true</span></span><br><span class="line">	debug.Println(<span class="string">"closed connection to"</span>, addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先我们可以看到在代码13行-16行，对连接进行请求的协商，也就是第一部分介绍的交互协商认证的流程。<br><strong>handShake代码如下</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func handShake(conn net.Conn) (err error) &#123;</span><br><span class="line">	const (</span><br><span class="line">		idVer     = 0</span><br><span class="line">		idNmethod = 1</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	buf := make([]byte, 258)</span><br><span class="line"></span><br><span class="line">	var n int</span><br><span class="line">	ss.SetReadTimeout(conn)</span><br><span class="line">	if n, err = io.ReadAtLeast(conn, buf, idNmethod+1); err != nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	if buf[idVer] != socksVer5 &#123;</span><br><span class="line">		return errVer</span><br><span class="line">	&#125;</span><br><span class="line">	nmethod := int(buf[idNmethod])</span><br><span class="line">	msgLen := nmethod + 2</span><br><span class="line">	if n == msgLen &#123; </span><br><span class="line">	&#125; else if n &lt; msgLen &#123; </span><br><span class="line">		if _, err = io.ReadFull(conn, buf[n:msgLen]); err != nil &#123;</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123; </span><br><span class="line">		return errAuthExtraData</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = conn.Write([]byte&#123;socksVer5, 0&#125;)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码11行读取了本地客户端发来的版本信息以及认证方法信息，如果协议版本不是socks5则立马返回。由于socks规定的字段ver与nmethods都是两个字节所以最后一个字段加上2个字节就是需要读取的信息总长度，最后第27行代码返回给客户端协议版本信息与选择的方法（此处不需要验证，所以传递0）。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rawaddr, addr, err := getRequest(conn)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Println(&quot;error getting request:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>然后让我们把视角在回到handleConnection函数，在完成handshake的认证后客户端会向local发送一个带有目的地址和端口的请求包，由request函数完成获取操作。以下是发送的包内容：<br>|VER|CMD|RSV|ATYP|DST.ADDR|DST.PORT|<br>:-:|:-:|:-:|<br>|1|1|0x00|1|Variable|2|</p>
<ul>
<li>VER:socks的版本</li>
<li>CMD:代表客户端请求的类型，值长度1个字节，有三种类型：<ul>
<li>Connect:0x01</li>
<li>Bind:0x02</li>
<li>UDP:0x03</li>
</ul>
</li>
<li>RSV:保留字段，默认0x00，长度1个字节</li>
<li>ATYP:代表请求的远程服务器地址类型，长度1个字节，三种类型：<ul>
<li>IPV4:0X01</li>
<li>IPV6:0X04</li>
<li>DOMAINNAME:0x03</li>
</ul>
</li>
<li>DST.ADDR:代表远程服务器的地址，根据ATYP进行解析，值长度不定</li>
<li>DST.PORT:代表远程服务器的端口，值长度2个字节</li>
</ul>
<p>当loca接收到该信息，接下来应当向客户端返回一个结果，在代码中默认返回了success。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, err = conn.Write([]byte&#123;0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x43&#125;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		debug.Println(&quot;send connection confirmation:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>当这些步骤完成后，接下来local端和server端建立连接。然后local负责把client的数据包加密后发送给ss-server。把收到的server数据包在发回给client。完成这些操作的函数就是PipeThenClose。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func PipeThenClose(src, dst net.Conn, addTraffic func(int)) &#123;</span><br><span class="line">	defer dst.Close()</span><br><span class="line">	buf := leakyBuf.Get()</span><br><span class="line">	defer leakyBuf.Put(buf)</span><br><span class="line">	for &#123;</span><br><span class="line">		SetReadTimeout(src)</span><br><span class="line">		n, err := src.Read(buf)</span><br><span class="line">		if addTraffic != nil &#123;</span><br><span class="line">			addTraffic(n)</span><br><span class="line">		&#125;</span><br><span class="line">		// read may return EOF with n &gt; 0</span><br><span class="line">		// should always process n &gt; 0 bytes before handling error</span><br><span class="line">		if n &gt; 0 &#123;</span><br><span class="line">			// Note: avoid overwrite err returned by Read.</span><br><span class="line">			if _, err := dst.Write(buf[0:n]); err != nil &#123;</span><br><span class="line">				Debug.Println(&quot;write:&quot;, err)</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			// Always &quot;use of closed network connection&quot;, but no easy way to</span><br><span class="line">			// identify this specific error. So just leave the error along for now.</span><br><span class="line">			// More info here: https://code.google.com/p/go/issues/detail?id=4373</span><br><span class="line">			/*</span><br><span class="line">				if bool(Debug) &amp;&amp; err != io.EOF &#123;</span><br><span class="line">					Debug.Println(&quot;read:&quot;, err)</span><br><span class="line">				&#125;</span><br><span class="line">			*/</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在PipeThenClose代码中，其申请一块缓冲区然后不停的从src中读取数据，将数据转发到dst中。当然，读取的时候需要对数据进行解密，写的时候需要加密。解密加密操作分别由项目中的Conn负责，其重写了read与write函数，在read时会根据加密方法对数据进行解密。write时则会进行加密。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go ss.PipeThenClose(conn, remote, nil)</span><br><span class="line">	ss.PipeThenClose(remote, conn, nil)</span><br><span class="line">	closed = true</span><br><span class="line">	debug.Println(&quot;closed connection to&quot;, addr)</span><br></pre></td></tr></table></figure></p>
<p>在handleConnection代码的最后，其使用两个PipeThenClose，新开启的goroutine和本身的goroutine病发的从本地到远程、远程到本地的上下行进行数据传输。</p>
<p>综上，handleConnection函数整体流程如下：</p>
<div id="flowchart-0" class="flow-chart"></div>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>local端的代码到此就算结束了，由于是按照整体流程进行分析，有些过于细节的地方几句就略过去了，重点还是在学习整体的流程以及socks协议的使用。server端的思路其实和local端比较类似，除了没有local中握手（handShake）的步骤。整体看来这个还是不太复杂的，整体代码也就2000行左右。</p>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">stat=>start: 开始
op1=>operation: handShake认证协商操作
op2=>operation: getRequest获取目标地址
op3=>operation: createServerConn创建与远程服务端的连接
op4=>operation: 利用PipeThenClose将数据传输至服务端(并发操作)
op5=>operation: 利用PipeThenClose从远程服务端接收数据
ed=>end: 结束

stat->op1->op2->op3->op4->op5->ed</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/28/go版本shadowsocks源码-二/" data-id="cjtsn5jga0005iu2xfnx855er" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/shadowsocks源码/">shadowsocks源码</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-go语言读书笔记-aciton系列（并发）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/27/go语言读书笔记-aciton系列（并发）/" class="article-date">
  <time class="post-time" datetime="2019-03-27T09:43:48.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br>
    <span class="post-day">27</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/27/go语言读书笔记-aciton系列（并发）/">go语言读书笔记-aciton系列（并发）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/go语言读书笔记/">go语言读书笔记</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>终于到并发了，阅读本章总有种go对并发的处理简洁高效的感觉。action系列举的实战例子也很通俗易懂，感觉运用一些实际的项目实践应该理解会更加深刻。</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>操作系统会在物理处理器上调度线程来运行程序，而Go语言运行时会在逻辑处理器上调用goroutine来运行。每个逻辑处理器都分别绑定到单个操作系统线程。<br>em。。goroutine可以理解为携程，就像这样。<br><img src="http://static.zybuluo.com/yiranblade/3efzy0kylh5qa5gt84q8e2dn/image_1d6fdftt11ti71crn1qn2c791uls9.png" alt="image_1d6fdftt11ti71crn1qn2c791uls9.png-230.1kB"><br>携程运行于线程之上，比线程更加轻量级。goroutine运行于逻辑处理器，而逻辑处理器就对应一个操作系统线程，其可以并发调度无数个groutine。</p>
<p>goroutine也可以并行运行，只要使用超过一个的逻辑处理器。但是只要底层硬件层面只有一个处理器，即使创建了多个逻辑处理器也依然是并发运行。<br><img src="http://static.zybuluo.com/yiranblade/2b8csvfn7li8kccrb5ftzl4p/image_1d6felqb512qn1r251k38110tchqm.png" alt="image_1d6felqb512qn1r251k38110tchqm.png-183.9kB"><br>并发并行的区别正如书上的图所示。<br>通过设置参数可以给每个可用的物理处理器分配一个逻辑处理器，从而达到并行的目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &quot;runtime&quot;</span><br><span class="line"></span><br><span class="line">runtime.GOMAXPROCS(runtime.NumCpu())</span><br></pre></td></tr></table></figure></p>
<h2 id="同步goroutine"><a href="#同步goroutine" class="headerlink" title="同步goroutine"></a>同步goroutine</h2><p>在写并发代码时，往往都会遇到竞争状态的问题。这就需要采用一些同步手段来得到正确的结果。go语言提供了锁的机制来同步。</p>
<h3 id="原子函数"><a href="#原子函数" class="headerlink" title="原子函数"></a>原子函数</h3><p>go sync包提供了一些常用的操作的原子函数。当使用这些函数来读，写时，其都会自动根据所引用的变量做同步处理。已addint64函数示例:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    counter <span class="keyword">int64</span></span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> incCounter(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> incCounter(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    wg.Wait()</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">"Final Counter:"</span>,counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> count :=<span class="number">0</span>; count&lt;<span class="number">2</span>;count++&#123;</span><br><span class="line">        atomic.AddInt64(&amp;counter,<span class="number">1</span>)</span><br><span class="line">        runtime.Goshed()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序一开始创建两个goroutine形成对counter变量的竞争条件。而AddInt64函数则强制同一时刻 只能有一个goroutine运行并完成这个加法操作。当goroutine试图取d去调用任何原子函数时，这些goroutine都会自动根据所引用的变量做同步处理。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁就和我们通常使用的许多语言中的锁机制一样，在代码中创建一个临界区，保证同一时间只有一个goroutine可以执行这个临界区的代码。<br>对刚刚的程序使用锁机制同步就是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;runtime&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;sync/atomic&quot;</span><br><span class="line">)</span><br><span class="line">var (</span><br><span class="line">    counter int64</span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    wg.Add(2)</span><br><span class="line">    </span><br><span class="line">    go incCounter(1)</span><br><span class="line">    go incCounter(2)</span><br><span class="line">    </span><br><span class="line">    wg.Wait()</span><br><span class="line">    </span><br><span class="line">    fmt.Println(&quot;Final Counter:&quot;,counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func incCounter(id int)&#123;</span><br><span class="line">    defer wg.Done()</span><br><span class="line">    for count :=0; count&lt;2;count++&#123;</span><br><span class="line">        mutex.Lock()</span><br><span class="line">        &#123;</span><br><span class="line">            value := counter</span><br><span class="line">            runtime.Gosched()</span><br><span class="line">            value++</span><br><span class="line">            counter = value</span><br><span class="line">        &#125;</span><br><span class="line">        mutex.UnLock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同一时刻只能有一个goroutine可以进入临界区。之后，直到调用Unlock()函数之后，其他goroutine才能进入临界区。</p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>go语言中提供了通道，通过发送和接收需要共享的资源，在goroutine之间做同步。<br><strong>通道分为无缓冲通道和有缓冲的通道。无缓冲的通道是指在接收前没有能力保存任何值的通道。这种类型的通道要求发送goroutine和接收goroutine同时准备好，才能完成发送和接收操作。如果两个goroutine没有同时准备好，通道会导致先执行发送或接收操作的goroutine阻塞等待。这种对通道进行发送和接收的交互行为本身就是同步的。</strong></p>
<p><strong>有缓冲的通道是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求goroutine之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值的时，发送动作才会阻塞。这导致有缓冲的通道和无缓冲的通道之间有一个很大的不同：无缓冲的通道保证进行发送和接收的goroutine会在同一时间进行数据交换了；有缓冲的通道没有这种保证。</strong></p>
<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>至此，对于goaction系列中对于go语言语法特性的部分，就算是阅读完毕了。书中举了很多这些语法的实际应用场景例子，但是实际掌握还是需要自己动手写以及多看看别人项目的源代码，个人感觉这样才能得到最快的提升。所以接下来的action章节读书笔记，就主要记录书中实际的demo吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/27/go语言读书笔记-aciton系列（并发）/" data-id="cjtsn5jgd000aiu2x3g01pt0x" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go语言/">go语言</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-go版本shadowsocks源码(一)" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/19/go版本shadowsocks源码(一)/" class="article-date">
  <time class="post-time" datetime="2019-03-19T12:01:52.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br>
    <span class="post-day">19</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/19/go版本shadowsocks源码(一)/">go版本shadowsocks源码(一)</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/源码/">源码</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="shadowsocks简介"><a href="#shadowsocks简介" class="headerlink" title="shadowsocks简介"></a>shadowsocks简介</h2><p>Shadowsocks（简称SS）是一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种开发包。当前包使用Python、C、C++、C#、Go语言等编程语言开发，大部分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。</p>
<p>而socks5协议则是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。根据OSI七层模型来划分，SOCKS属于会话层协议，位于表示层与传输层之间。</p>
<p>当防火墙后的客户端要访问外部的服务器时，就跟socks代理服务器连接。该协议设计之初是为了让有权限的用户可以穿过过防火墙的限制，使得高权限用户可以访问外部资源。经过10余年的时间，大量的网络应用程序都支持socks5代理。</p>
<hr>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>首先我们来看下客户端的代码。</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>go语言和大多数语言一样都是从main函数开始的，在源码阅读的过程我们也从main函数开始逐步往下分析。<br>mian函数整体我认为可以分为三个部分，第一部分读取相关的配置信息，第二部分处理服务器配置信息，第三部分启动客户端，监听本地端口。</p>
<h4 id="读取客户端启动的配置信息"><a href="#读取客户端启动的配置信息" class="headerlink" title="读取客户端启动的配置信息"></a>读取客户端启动的配置信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">                       ......</span><br><span class="line">   flag.BoolVar(&amp;printVer, &quot;version&quot;, false, &quot;print version&quot;)</span><br><span class="line">flag.StringVar(&amp;configFile, &quot;c&quot;, &quot;config.json&quot;, &quot;specify config file&quot;)</span><br><span class="line">flag.StringVar(&amp;cmdServer, &quot;s&quot;, &quot;&quot;, &quot;server address&quot;)</span><br><span class="line">flag.StringVar(&amp;cmdConfig.LocalAddress, &quot;b&quot;, &quot;&quot;, &quot;local address, listen only to this address if specified&quot;)</span><br><span class="line">flag.StringVar(&amp;cmdConfig.Password, &quot;k&quot;, &quot;&quot;, &quot;password&quot;)</span><br><span class="line">flag.IntVar(&amp;cmdConfig.ServerPort, &quot;p&quot;, 0, &quot;server port&quot;)</span><br><span class="line">flag.IntVar(&amp;cmdConfig.Timeout, &quot;t&quot;, 300, &quot;timeout in seconds&quot;)</span><br><span class="line">flag.IntVar(&amp;cmdConfig.LocalPort, &quot;l&quot;, 0, &quot;local socks5 proxy port&quot;)</span><br><span class="line">flag.StringVar(&amp;cmdConfig.Method, &quot;m&quot;, &quot;&quot;, &quot;encryption method, default: aes-256-cfb&quot;)</span><br><span class="line">flag.BoolVar((*bool)(&amp;debug), &quot;d&quot;, false, &quot;print debug message&quot;)</span><br><span class="line">flag.StringVar(&amp;cmdURI, &quot;u&quot;, &quot;&quot;, &quot;shadowsocks URI&quot;)</span><br><span class="line">                    ......</span><br><span class="line">                    </span><br><span class="line">config, err := ss.ParseConfig(configFile)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">	config = &amp;cmdConfig</span><br><span class="line">	if !os.IsNotExist(err) &#123;</span><br><span class="line">		fmt.Fprintf(os.Stderr, &quot;error reading %s: %v\n&quot;, configFile, err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	ss.UpdateConfig(config, &amp;cmdConfig)</span><br><span class="line">&#125;</span><br><span class="line">if config.Method == &quot;&quot; &#123;</span><br><span class="line">	config.Method = &quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中我们可以看到，除了从命令行读取配置信息外，还可以指定json文件读取配置信息。ss的配置信息包括这样几个部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   Server       interface&#123;&#125; `json:&quot;server&quot;`</span><br><span class="line">ServerPort   int         `json:&quot;server_port&quot;`</span><br><span class="line">LocalPort    int         `json:&quot;local_port&quot;`</span><br><span class="line">LocalAddress string      `json:&quot;local_address&quot;`</span><br><span class="line">Password     string      `json:&quot;password&quot;`</span><br><span class="line">Method       string      `json:&quot;method&quot;` // encryption method</span><br><span class="line"></span><br><span class="line">// following options are only used by server</span><br><span class="line">PortPassword map[string]string `json:&quot;port_password&quot;`</span><br><span class="line">Timeout      int               `json:&quot;timeout&quot;`</span><br><span class="line"></span><br><span class="line">// following options are only used by client</span><br><span class="line"></span><br><span class="line">// The order of servers in the client config is significant, so use array</span><br><span class="line">// instead of map to preserve the order.</span><br><span class="line">ServerPassword [][]string `json:&quot;server_password&quot;`</span><br></pre></td></tr></table></figure></p>
<p>从上往下分为客户端配置和服务端配置，其中客户端配置包括远程服务器ip，服务器端口，本地端口，本地地址访问密码，加密方法，服务端配置包括设定端口密码等。<br>对于go语言来说从命令行读取相应的参数感觉是一件十分方便的事情<br>，只要调用flag包相关函数即可读取并规定想要的格式参数。</p>
<h4 id="处理服务器配置信息"><a href="#处理服务器配置信息" class="headerlink" title="处理服务器配置信息"></a>处理服务器配置信息</h4><p>服务器配置信息这里使用了两个结构体来存储读取的配置信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type ServerCipher struct &#123;</span><br><span class="line">	server string</span><br><span class="line">	cipher *ss.Cipher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var servers struct &#123;</span><br><span class="line">	srvCipher []*ServerCipher</span><br><span class="line">	failCnt   []int // failed connection count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实阅读这里我是不太理解，为什么要在用一个匿名结构体将server密码信息包起来的，而且servercipher这个名字也怪怪的，因为里面不仅仅包含server的密码信息呀。可能是因为单独记录shi失败次数有利于后续扩展？这个后面想到在补吧。使用数组就很显然了，为了支持配置多个服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">func parseServerConfig(config *ss.Config) &#123;</span><br><span class="line">	hasPort := func(s string) bool &#123;</span><br><span class="line">		_, port, err := net.SplitHostPort(s)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return false</span><br><span class="line">		&#125;</span><br><span class="line">		return port != &quot;&quot;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if len(config.ServerPassword) == 0 &#123;</span><br><span class="line">		// only one encryption table</span><br><span class="line">		cipher, err := ss.NewCipher(config.Method, config.Password)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			log.Fatal(&quot;Failed generating ciphers:&quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line">		srvPort := strconv.Itoa(config.ServerPort)</span><br><span class="line">		srvArr := config.GetServerArray()</span><br><span class="line">		n := len(srvArr)</span><br><span class="line">		servers.srvCipher = make([]*ServerCipher, n)</span><br><span class="line"></span><br><span class="line">		for i, s := range srvArr &#123;</span><br><span class="line">			if hasPort(s) &#123;</span><br><span class="line">				log.Println(&quot;ignore server_port option for server&quot;, s)</span><br><span class="line">				servers.srvCipher[i] = &amp;ServerCipher&#123;s, cipher&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				servers.srvCipher[i] = &amp;ServerCipher&#123;net.JoinHostPort(s, srvPort), cipher&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// multiple servers</span><br><span class="line">		n := len(config.ServerPassword)</span><br><span class="line">		servers.srvCipher = make([]*ServerCipher, n)</span><br><span class="line"></span><br><span class="line">		cipherCache := make(map[string]*ss.Cipher)</span><br><span class="line">		i := 0</span><br><span class="line">		for _, serverInfo := range config.ServerPassword &#123;</span><br><span class="line">			if len(serverInfo) &lt; 2 || len(serverInfo) &gt; 3 &#123;</span><br><span class="line">				log.Fatalf(&quot;server %v syntax error\n&quot;, serverInfo)</span><br><span class="line">			&#125;</span><br><span class="line">			server := serverInfo[0]</span><br><span class="line">			passwd := serverInfo[1]</span><br><span class="line">			encmethod := &quot;&quot;</span><br><span class="line">			if len(serverInfo) == 3 &#123;</span><br><span class="line">				encmethod = serverInfo[2]</span><br><span class="line">			&#125;</span><br><span class="line">			if !hasPort(server) &#123;</span><br><span class="line">				log.Fatalf(&quot;no port for server %s\n&quot;, server)</span><br><span class="line">			&#125;</span><br><span class="line">			// Using &quot;|&quot; as delimiter is safe here, since no encryption</span><br><span class="line">			// method contains it in the name.</span><br><span class="line">			cacheKey := encmethod + &quot;|&quot; + passwd</span><br><span class="line">			cipher, ok := cipherCache[cacheKey]</span><br><span class="line">			if !ok &#123;</span><br><span class="line">				var err error</span><br><span class="line">				cipher, err = ss.NewCipher(encmethod, passwd)</span><br><span class="line">				if err != nil &#123;</span><br><span class="line">					log.Fatal(&quot;Failed generating ciphers:&quot;, err)</span><br><span class="line">				&#125;</span><br><span class="line">				cipherCache[cacheKey] = cipher</span><br><span class="line">			&#125;</span><br><span class="line">			servers.srvCipher[i] = &amp;ServerCipher&#123;server, cipher&#125;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	servers.failCnt = make([]int, len(servers.srvCipher))</span><br><span class="line">	for _, se := range servers.srvCipher &#123;</span><br><span class="line">		log.Println(&quot;available remote server&quot;, se.server)</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理服务器配置信息主要由parseServerConfig函数完成，老实说我不太喜欢这个函数，写的又臭又长看起来也很费劲，应该很有优化的空间的。<br>函数整体应该分为两个部分，用一个if分支隔离开来。if直接跟的语句负责处理单个服务器配置的信息，else跟的部分负责多个服务器配置信息的解析。整体流程如下：</p>
<p><div id="flowchart-0" class="flow-chart"></div></p>
<h4 id="开启go携程监听本地端口"><a href="#开启go携程监听本地端口" class="headerlink" title="开启go携程监听本地端口"></a>开启go携程监听本地端口</h4><p>run方法是比较简单的，使用tcp协议监听指定地址端口，采用轮询机制等待连接请求，一旦等到连接后开启一个goroutine调用 handleConnection()进行处理。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(listenAddr <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	ln, err := net.Listen(<span class="string">"tcp"</span>, listenAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">"starting local socks5 server at %v ...\n"</span>, listenAddr)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := ln.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(<span class="string">"accept:"</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> handleConnection(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##结语<br>至此，main函数的整体就差不多，接下来我们需要看下在拿到请求后，handleConnection函数是怎样对其进行处理的。</p>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start
op1=>operation: 传入服务器配置信息
cond=>condition: 是否多个配置项?
opY1=>operation: 建立ss.Cipher数组
opY2=>operation: 循环读取配置信息最后写入全局变量servers
opN1=>operation: 设置加密方法，提取ip数组
opN2=>operation: 循环设置相关信息
e=>end

st->op1->cond
cond(yes)->opY1->opY2->e
cond(no)->opN1->opN2->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/19/go版本shadowsocks源码(一)/" data-id="cjtsn5jg80004iu2xkd4b1n8p" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/shadowsocks源码/">shadowsocks源码</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-go语言读书笔记-action系列(方法与接口）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/11/go语言读书笔记-action系列(方法与接口）/" class="article-date">
  <time class="post-time" datetime="2019-03-11T08:07:20.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br>
    <span class="post-day">11</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/11/go语言读书笔记-action系列(方法与接口）/">go语言读书笔记-action系列(方法与接口)</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/go语言读书笔记/">go语言读书笔记</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="方法简单概述"><a href="#方法简单概述" class="headerlink" title="方法简单概述"></a>方法简单概述</h2><p>go语言中，方法是用来给用户定义的类型添加新的行为。要想给类型添加方法，只需要在函数关键字func和函数名之间加一个参数，这个参数就被称为接收者，将函数与接收者的类型绑定在一起。函数有接收者就被称为方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type user struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    email string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u user) notify() &#123;</span><br><span class="line">    fmt.Printf(&quot;hello world!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ok，其实关于这一篇读书笔记我重点想记录的是接口，关于方法大概声明就是这样，使用的套路和java、php等各种面向对象的语言都是差不多。</p>
<hr>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>go语言中的接口，个人感觉和java，php中这类相比，与实现者之间的联系真的是十分薄弱，其不需要使用任何显式的关键字指明要实现该接口。只要类型绑定了同样的方法就认为其实现了该接口，就可以赋值给该接口类型。也就是说go中需要实现某个接口不需要显式的指明实现哪一个，想实现哪个接口直接编写该方法就可以，不想实现后就删除该方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type notifier inteface &#123;</span><br><span class="line">    notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type user struct&#123;</span><br><span class="line">    name string</span><br><span class="line">    email string</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">func (u *user) notify()&#123;</span><br><span class="line">    fmt.Printf(&quot;Sending user email to %s&lt;%s&gt;\n&quot;,u.name,u.email)</span><br><span class="line">&#125;</span><br><span class="line">//这就可以说user类型实现了notifier 接口</span><br><span class="line">func main（)&#123;</span><br><span class="line">    var n notifier</span><br><span class="line">    n = user&#123;&quot;bill&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="接口的内部实现"><a href="#接口的内部实现" class="headerlink" title="接口的内部实现"></a>接口的内部实现</h2><p><img src="http://static.zybuluo.com/yiranblade/ids8bjg2xxb5yhbk7ecmoh4m/image_1d5llurtkgeq6kr1oln1gj0igdm.png" alt="image_1d5llurtkgeq6kr1oln1gj0igdm.png-126.9kB"></p>
<p>上图展示了在user类型值赋值后接口变量的值的内部布局。接口值是一个两个字长度的数据结构，第一个字包含一个指向内部表的指针。这个内部表叫iTable，包含了所存储的值的类型信息。iTable包含了已存储的值的类型信息以及与这个值相关联的一组方法。第二个字是一个指向所存储值的指针。</p>
<p><img src="http://static.zybuluo.com/yiranblade/1qecorn6y0a92pregavnwkoc/image_1d5lmui17tig1l7p1ec91bv31m4k2g.png" alt="image_1d5lmui17tig1l7p1ec91bv31m4k2g.png-128.5kB"></p>
<p>当把指针赋值给接口之后，类型信息会存储一个指向保存类型的指针，而接口值第二个字依旧保存指向实体值的指针。</p>
<hr>
<h2 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h2><p>方法集定义了接口的接受规则。当使用指针接收者来实现接口时，值类型则无法实现该接口。这是因为值类型的方法集只包括值接收者声明的方法，所以值类型无法实现指针接收者声明的方法。、</p>
<ul>
<li>以下是go语言规范里描述的方法集：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">Values</th>
<th style="text-align:center">Methods</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center">(t T)</td>
</tr>
<tr>
<td style="text-align:center">*T</td>
<td style="text-align:center">(t T) and (t *T)</td>
</tr>
</tbody>
</table>
<p><strong>T类型的值的方法集只包含值接收者声明的方法。而指向T类型的指针的方法集既包含值接收者声明的方法，也包含指针接收者声明的方法。</strong></p>
<ul>
<li>从接收者类型角度来看方法集</li>
</ul>
<table>
<thead>
<tr>
<th>Methods Receivers</th>
<th>Values</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>(t T)</td>
</tr>
<tr>
<td>*T</td>
<td>(t T) and (t *T)</td>
</tr>
</tbody>
</table>
<p>这个实际上和上面那个说的是同一件事，只不过换了个视角。如果使用指针接收者来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口。如果使用值接收者来实现一个接口，那么那个类型的值和指针都能够实现对应的接口。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇主要记录了，go中方法的简单使用以及初步了解了下接口内部的存储方式。对于接口其实我当初在看go圣经时就一直很疑惑，为什么要有值和指针方法集这种限制，为什么不可以值也传递给指针接收者。action 中也给出了回答—<strong>编译器并不是总能自动获得一个值的地址</strong>。这就好像不可能把值传递给一个行参为指针的函数一样，编译器并不总会帮我们主动获取到值的地址。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/11/go语言读书笔记-action系列(方法与接口）/" data-id="cjtsn5jgb0006iu2xchp46ryi" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go接口/">go接口</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-go语言读书笔记-action系列(类型)" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/11/go语言读书笔记-action系列(类型)/" class="article-date">
  <time class="post-time" datetime="2019-03-11T03:06:54.751Z" itemprop="datePublished">
    <span class="post-month">3月</span><br>
    <span class="post-day">11</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/11/go语言读书笔记-action系列(类型)/">go语言读书笔记-action系列(类型)</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/go语言读书笔记/">go语言读书笔记</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="用户定义的类型"><a href="#用户定义的类型" class="headerlink" title="用户定义的类型"></a>用户定义的类型</h2><p>实际上这里指的就是结构体，go语言中创建结构体的方式与c中基本大同小异，但是go会每次用上一个type 相当于给这个结构体一个命名，这一点不同于c中的用法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//go语言写法</span><br><span class="line">type user strut &#123;</span><br><span class="line">    name string</span><br><span class="line">    email string </span><br><span class="line">    ext int</span><br><span class="line">    privileged bool</span><br><span class="line">&#125;</span><br><span class="line">//c语言写法</span><br><span class="line">struct user &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    char *email;</span><br><span class="line">    int ext;</span><br><span class="line">    bool privileged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然c也可以用typedef这个关键字 给予别名使用。</p>
<p>但是go中的type 定义的类型会被认定为一个新的类型，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type blade int</span><br></pre></td></tr></table></figure></p>
<p>这个blade会被认为是全新的类型，将int类型赋值给它时会报错，c语言中就仅仅只是个别名的意思，赋值依然可以。</p>
<p>##内置类型<br>内置类型指的就是数值类型、字符串类型和布尔类型，也就是常说的int，string这类的。因为其是原始类型，所以对其进行增加或者删除都会创建新值，因为其底层结构不共享。<br>action中举了这样一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func Trim(s string, cutset string) string&#123;</span><br><span class="line">    if s == &quot;&quot; || cutset == &quot;&quot;nc&#123;</span><br><span class="line">        return s</span><br><span class="line">    &#125;</span><br><span class="line">    return TrimFunc(s,makeCutsetFunc(cutset))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数对调用者原始的string值的一个副本进行操作，并且返回一个新的string值做副本。字符串就像整数、浮点数和布尔值一样，本质上是一种很原始的数据值，所以在函数或方法内外传递时，要传递字符串的一份副本。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>go语言中的引用类型有：切片、映射、通道、接口、和函数类型。创建上述类型的变量是共享底层数据结构的。<br>�由于其底层共享结构，所以不需要通过指针来共享引用类型的值，而通过复制来传递引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (ip IP) MarshalText() ([]byte,error)&#123;</span><br><span class="line">    if len(ip) == 0&#123;</span><br><span class="line">        return []byte(&quot;&quot;),nil</span><br><span class="line">    &#125;</span><br><span class="line">    if len(ip) != IPV4len &amp;&amp; len(ip) !=IPv6len&#123;</span><br><span class="line">        return nil,erroes.New(&quot;invalid IP address&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return []byte(ip.String()),nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码，正如预期的那样通过复制来传递引用，从而不需要通过指针来共享引用类型的值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>go语言中的类型大体上就分为这几类，在其作为方法的参数时，创建新的值就用值接收者，否则就用指针。这就是保持传递的一致性。内置类型与引用类型传递的时候，就需要把握其特性再根据传递原则决定如何使用，比如引用类型因为其底层共享结构，就不用传递指针，仅仅传递引用的副本就可以完成修改值的操作，而内置类型就需要指针。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/11/go语言读书笔记-action系列(类型)/" data-id="cjtsn5jge000biu2x9gu56zph" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go数据类型/">go数据类型</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-go语言读书笔记-action系列（映射）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/01/go语言读书笔记-action系列（映射）/" class="article-date">
  <time class="post-time" datetime="2019-03-01T06:43:32.361Z" itemprop="datePublished">
    <span class="post-month">3月</span><br>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/01/go语言读书笔记-action系列（映射）/">go语言读书笔记-action系列（映射）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/go语言读书笔记/">go语言读书笔记</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于习惯了map这种表述方式的我，现在看来还是go中使用映射这个词，表达这一结构感觉更加精准点。</p>
<h2 id="映射内部实现方式"><a href="#映射内部实现方式" class="headerlink" title="映射内部实现方式"></a>映射内部实现方式</h2><p>映射的内部是无序的，因为其使用了散列表。<br><img src="http://static.zybuluo.com/yiranblade/f73al21v28v8ixnbx7b09813/image_1d4rk5af2rkt1taiego1ied6jv9.png" alt="image_1d4rk5af2rkt1taiego1ied6jv9.png-156.1kB"></p>
<p>映射的散列结构包含一组桶，所有的操作都要先选择一个桶。把操作映射时指定的键传递给映射的散列函数就可以选中对应的桶。<br>go语言生成散列键的过程如下：</p>
<ol>
<li>这些字符串会转换为一个数值（散列值）。</li>
<li>这个数值落在映射已有桶的序号范围内表示一个可以用于存储的桶的序号。</li>
<li>最后这个数值被用来选择桶，用于存储或者查找指定的键值对。</li>
</ol>
<p>在此需要强调的是，散列值的低位用来选择桶，高位用来区分不同的项。<br>对于桶的内部实现，感觉action中解释的并不是很好，尤其这个散列值高位的作用，解释感觉很难理解。<br>桶的内部实现使用两个数据结构实现。第一个是数组，内部存储的是用于选择桶的散列键的高位值（在对key/value对增删查的时候，先比较key的hash值高八位是否相等，然后再比较具体的key值，主要用来帮助区分寻找对应的key，不用每次都对key做全等判断）。第二个数据结构是一个字节数组，用于存储键值对。该字节数组存储了这个桶里所有的键，之后依次存储了这个桶里所有的值。</p>
<h2 id="映射的扩容"><a href="#映射的扩容" class="headerlink" title="映射的扩容"></a>映射的扩容</h2><p>action没有提到这一点，但是我觉得应该去探索下。<br>在桶中插入元素时，当桶填满后，将通过overflow指针来mallocgc一个新的bucket出来形成链表。<br>随着元素的增长，在桶链中寻找特定的key会变得效率低下，所以再插入的元素个数/桶达到阙值时（貌似设置为6.5），map会扩容，创建新的桶数组，长度为之前长度的两倍。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/01/go语言读书笔记-action系列（映射）/" data-id="cjtsn5jgh000giu2x7cnlmmig" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go映射/">go映射</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-go语言读书笔记-action系列（切片）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/01/go语言读书笔记-action系列（切片）/" class="article-date">
  <time class="post-time" datetime="2019-03-01T02:48:28.249Z" itemprop="datePublished">
    <span class="post-month">3月</span><br>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/01/go语言读书笔记-action系列（切片）/">go语言读书笔记-action系列（切片）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/go语言读书笔记/">go语言读书笔记</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>go语言中的切片，感觉就像动态数组一样，自由的增删元素，更改大小。相比数组的固定大小，在编程中提供了不小的方便。不同于java中数据集合的各种抽象（map，set，list），以及三大基础结构底下的各个容器，go的集合表示很简单，就只有数组、切片、映射（当然比起php一切皆array逊色很多，但是我go快啊），感觉go应该是总结了各个语言的特性，总结除了这三种最具有普适性的结构，从而可以适应各种需要。</p>
<h2 id="切片的内部实现"><a href="#切片的内部实现" class="headerlink" title="切片的内部实现"></a>切片的内部实现</h2><p><img src="http://static.zybuluo.com/yiranblade/syopmcwvx1qov3ib7ybvglpa/image_1d4rgl7v3tf2110v19hd80t1q1dp.png" alt="image_1d4rgl7v3tf2110v19hd80t1q1dp.png-66.2kB"><br>在go中，切片可以看作对底层数组所做的抽象，切片的数据包含三个字段：</p>
<ul>
<li>指向数组的指针</li>
<li>切片访问元素的个数</li>
<li>允许增长到的元素个数（就是切片的容量，占用的内存空间）</li>
</ul>
<p>通过这种结构，明显可以发现在使用切片时需要十分小心，因为其共享底层数组，可能一不小心就会干扰到其它切片的元素。<br>但是这种结构也使得切片在函数间传递时不用像数组那样传递过大的数据量，无论多大的切片都只有24个字节（指针8个，元素个数8个，容量8个），极大的提升了效率。</p>
<h2 id="append"><a href="#append" class="headerlink" title="append"></a>append</h2><p>使用append可以向切片中增加元素:</p>
<h4 id="func-append-slice-Type-elems-…Type-Type"><a href="#func-append-slice-Type-elems-…Type-Type" class="headerlink" title="func append(slice []Type, elems …Type) []Type"></a>func append(slice []Type, elems …Type) []Type</h4><p>append 在切片容量足够时，直接将元素插入底层数组并更新切片访问元素的个数。切片的容量在不足够时append会自动生成新的切片增加容量，每次增加的容量是原来的两倍。但是当元素个数超过1000时，append容量的增长因子会被设为1.25。</p>
<h2 id="创建切片的三个索引"><a href="#创建切片的三个索引" class="headerlink" title="创建切片的三个索引"></a>创建切片的三个索引</h2><p>在创建切片时，原来还可以使用第三个索引，第三个索引是用来控制切片的容量。</p>
<ul>
<li>为什么需要限制切片的容量？</li>
</ul>
<h4 id="因为切片存在多个切片共用一个数组的情况，有时可能会由于误操作影响到其他切片，所以设置了容量的情况下，在添加元素时就可以强制使得append为了增加容量申请新的底层数组，从而保证即使误操作也不会影响到其它切片。"><a href="#因为切片存在多个切片共用一个数组的情况，有时可能会由于误操作影响到其他切片，所以设置了容量的情况下，在添加元素时就可以强制使得append为了增加容量申请新的底层数组，从而保证即使误操作也不会影响到其它切片。" class="headerlink" title="因为切片存在多个切片共用一个数组的情况，有时可能会由于误操作影响到其他切片，所以设置了容量的情况下，在添加元素时就可以强制使得append为了增加容量申请新的底层数组，从而保证即使误操作也不会影响到其它切片。"></a>因为切片存在多个切片共用一个数组的情况，有时可能会由于误操作影响到其他切片，所以设置了容量的情况下，在添加元素时就可以强制使得append为了增加容量申请新的底层数组，从而保证即使误操作也不会影响到其它切片。</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/01/go语言读书笔记-action系列（切片）/" data-id="cjtsn5jgp000niu2xayc2ucis" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go切片/">go切片</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-go语言读书笔记-action系列（一个简单的go程序）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/26/go语言读书笔记-action系列（一个简单的go程序）/" class="article-date">
  <time class="post-time" datetime="2019-02-26T13:15:03.703Z" itemprop="datePublished">
    <span class="post-month">2月</span><br>
    <span class="post-day">26</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/26/go语言读书笔记-action系列（一个简单的go程序）/">go语言读书笔记-action系列（一个简单的go程序）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/go语言读书笔记/">go语言读书笔记</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>action系列的书感觉还是挺经典的，入手后直接跳过第一章介绍，从第二章开始。在第二章中，其主要以一个搜索的小demo来整体回顾了下go的基础语法，以及鲜明特性，通道，携程之类的，顺读下来感觉对于之前读圣经积累下来的基础是一个十分不错的回顾。</p>
<h2 id="快速开始一个go程序"><a href="#快速开始一个go程序" class="headerlink" title="快速开始一个go程序"></a>快速开始一个go程序</h2><p>书中的demo是一个从不同数据源中进行搜索的程序，其实现了json与rss这两种格式的读取与搜索，程序的整体架构如下：<br><img src="http://static.zybuluo.com/yiranblade/cyys3bjkuc07sxy558jlc0ch/image_1d4ku4v57nbldgti1b6eb1aok9.png" alt="image_1d4ku4v57nbldgti1b6eb1aok9.png-144.6kB"><br>程序的目录结构分为data，matchers,search三个部分，main一贯作为程序的主入口执行整个程序。<br>从中get到的新的点，感觉就是对于init的使用，预先在各个包中初始化matcher的类型，感觉就像传统面向对象的初始化工厂对象一样。以及对于接口的绑定感觉很有意思，像php，java等对于接口都要使用关键字implements强实现，而go不同，任何一个struct只要绑定了对应方法那么就可以视为其实现了该对象就可以对其赋值，这种弱关联性，对于习惯了php，java那种写法的方式一开始kennel会感觉很不适应但是习惯了，真的感觉很nice，程序写起来就有种用最少的组件做最多的事情的感觉，唯一不爽的就还是觉得代码可读性，没java那么的高，也可能是我习惯了java。</p>
<h2 id="接口的赋值"><a href="#接口的赋值" class="headerlink" title="接口的赋值"></a>接口的赋值</h2><p>对于一个绑定方法结构体，如果其传入是值的话，则其接口引用类型无论是值还是指针都可以直接调用方法。如果传入的是指针的话，就只可以在接口引用类型是指针的情况下进行方法调用。举例如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法声明为使用指向 defaultMatcher 类型值的指针作为接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *defaultMatcher)</span> <span class="title">Search</span><span class="params">(feed *Feed, searchTerm <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function">// 通过 <span class="title">interface</span> 类型的值来调用方法</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">dm</span> <span class="title">defaultMatcher</span></span></span><br><span class="line">var matcher Matcher = dm // 将值赋值给接口类型 matcher.Search(feed, "test") // 使用值来调用接口方法</span><br><span class="line">&gt; <span class="keyword">go</span> build</span><br><span class="line">cannot use dm (<span class="keyword">type</span> defaultMatcher) as <span class="keyword">type</span> Matcher in assignment</span><br><span class="line"><span class="comment">// 方法声明为使用 defaultMatcher 类型的值作为接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m defaultMatcher)</span> <span class="title">Search</span><span class="params">(feed *Feed, searchTerm <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function">// 通过 <span class="title">interface</span> 类型的值来调用方法</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">dm</span> <span class="title">defaultMatcher</span></span></span><br><span class="line">var matcher Matcher = &amp;dm // 将指针赋值给接口类型 matcher.Search(feed, "test") // 使用指针来调用接口方法</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/26/go语言读书笔记-action系列（一个简单的go程序）/" data-id="cjtsn5jgn000jiu2xdsur5hx3" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go简单语法/">go简单语法</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-TCP连接详解" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/24/TCP连接详解/" class="article-date">
  <time class="post-time" datetime="2019-02-24T03:33:40.674Z" itemprop="datePublished">
    <span class="post-month">2月</span><br>
    <span class="post-day">24</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/24/TCP连接详解/">TCP连接详解</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络协议/">网络协议</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h2><p>（1）服务器必须准备好接受连接。通常通过调用socket、bind和listen这3个函数完成，这被称为被动打开。<br>（2）客户通过调用connect发起主动打开。这导致客户tcp发送一个syn（同步）分节，它会告诉服务器客户将在连接中发送的数据的初始序列号。通常syn分节不携带数据，其所在ip数据报hozhi只含有一个ip首部、一个tcp首部及可能有的tcp选项。<br>（3）服务器必须确认客户（ack acknowledge）d的syn，同事自己也要发送一个syn分节，它含有服务器将在同一个连接中发送的数据的初始序列号。服务器将在单个分节中发送syn和对客户syn的ack（确认）。<br>（4）客户必须确认服务器的syn哦。<br>这种交换需要三个分组，所以被称为tcp的三次握手。</p>
<h2 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h2><p>（1）某个应用进程首先调用close，我们称该端执行主动关闭。该端的TCP于是发送一个fin分节，表示数据发送完毕。<br>（2）接收到这个fin的对端执行被动关闭。这个fin由tcp确认。它的接收也作为一个文件结束符传递给接收端应用进程，fin的接收意味着接收端应用进程在相应连接上再无额外数据可接收。<br>（3）一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的tcp也发送一个fin。<br>（4）接收这个最终fin的愿发送端tcp确认这个fin。</p>
<h2 id="tcp连接过程中的状态转移"><a href="#tcp连接过程中的状态转移" class="headerlink" title="tcp连接过程中的状态转移"></a>tcp连接过程中的状态转移</h2><p>tcp为一个连接定义了11种状态，且tcp规则规定如何基于当前状态及在该状态下所接收的分节从一个状态转换到另一个状态。<br>在此说明下：<br><img src="http://static.zybuluo.com/yiranblade/9xl6j1x2fuff5x4z3joodvpm/image.png" alt="image.png-510.5kB"><br>对于一个经典的断开操作其示意图如下：<br><img src="http://static.zybuluo.com/yiranblade/3luaqmf17dfvlnoynv7e4f1s/image.png" alt="image.png-108.9kB"></p>
<p>##TTIME_WAIT状态<br>一般执行主动关闭的一端会经历这个状态，该端停留在该状态的持续时间是最长分节生命期的两倍,2MSL。<br>TIME_WAIT状态有两个存在的理由：<br>（1）可靠地实现TCP全双工连接的终止；<br>（2）允许老的重复分节在网络中消逝。<br>第一个理由是，假设在四次挥手最后的ack丢失，那么发起端就必须重新发送ack。第二个则是，tcp必须防止来自某个连接的老的重复分组在该连接已终止后再现，从而被误解成属于同一连接的某个新的化身。而tcp不会给处于time_wait状态的连接发起新的化身。而time_wait状态的持续时间是msl的2倍，所以无论哪个方向的分组将最多存活msl秒后即被丢弃，这样就可以保证每成功建议一个tcp连接时。来自该连接先前化身的老的重复分组都已在网络中消逝了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/24/TCP连接详解/" data-id="cjtsn5jg40001iu2xigbzb1g2" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp/">tcp</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">next &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">yiranblade&#39;s blog</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author"></h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>11</strong><br>文章</div></a>
      <a href="/categories"><div><strong>3</strong><br>分类</div></a>
      <a href="/tags"><div><strong>9</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/yiranblade" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="http://blog.yiranblade.cn/" target="_blank" title="ShanaMaid">
          ShanaMaid
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2018 - 2019 yiranblade&#39;s blog<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>

    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>

<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title class="menuItem">首页</a>
          
            <a href="/tags" title class="menuItem">标签</a>
          
            <a href="/categories" title class="menuItem">分类</a>
          
            <a href="/archives" title class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>







  </div>
</body>
</html>