<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>yiranblade&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="yiranblade&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="yiranblade&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yiranblade&#39;s blog">
  
    <link rel="alternate" href="/atom.xml" title="yiranblade&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author"></h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>20</strong><br>文章</div></a>
      <a href="/categories"><div><strong>7</strong><br>分类</div></a>
      <a href="/tags"><div><strong>12</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-调度算法" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/01/调度算法/" class="article-date">
  <time class="post-time" datetime="2019-08-01T08:45:26.000Z" itemprop="datePublished">
    <span class="post-month">8月</span><br>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/01/调度算法/">调度算法</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/操作系统/">操作系统</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="调度层次"><a href="#调度层次" class="headerlink" title="调度层次"></a>调度层次</h2><ul>
<li>高级调度（作业调度）<ul>
<li>作业<br>  包含通常的程序和数据，而且还应配有一份作业说明书。</li>
</ul>
</li>
<li>低级调度（进程调度）<ul>
<li>调度方式<ul>
<li>非抢占方式</li>
<li>抢占方式<ul>
<li>优先权原则</li>
<li>短作业优先原则</li>
<li>时间片原则</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>中级调度<ul>
<li>中级调度(Intermediate Level Scheduling)又称中程调度(Medium-Term Scheduling)。引入 中级调度的主要目的是为了提高内存利用率和系统吞吐量。 </li>
</ul>
</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>1.先来先服务调度算法（FCFS）<br>2.短作业优先调度算法（SJF）<br>3.高响应比优先调度算法<br>4.时间片轮转<br>5.多级反馈队列调度</p>
<p>##死锁的原因和必要条件</p>
<ul>
<li>原因<br>（1）竞争资源<br>（2）进程间推进顺序非法。</li>
<li><p>必要条件<br>1.互斥条件<br>2.请求和保持条件<br>3.不可剥夺条件<br>4.环路等待条件</p>
</li>
<li><p>解决死锁的方法</p>
<ol>
<li>预防死锁<ul>
<li>摒弃“请求和保持”条件 </li>
<li>摒弃“不剥夺”条件</li>
<li>摒弃“环路等待”条件</li>
</ul>
</li>
<li>避免死锁<ul>
<li>安全状态 </li>
</ul>
</li>
<li>检测死锁</li>
<li>解除死锁</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/01/调度算法/" data-id="cjyshtzra0017kz2xunapg8fb" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统复习/">操作系统复习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-进程相关" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/01/进程相关/" class="article-date">
  <time class="post-time" datetime="2019-08-01T06:37:35.000Z" itemprop="datePublished">
    <span class="post-month">8月</span><br>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/01/进程相关/">进程相关</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/操作系统/">操作系统</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>试说明进程在三个基本状态之间转换的典型原因</p>
<ul>
<li>就绪状态-&gt;执行状态：进程分配到CPU资源</li>
<li>执行状态-&gt;就绪状态：时间片用完</li>
<li>执行状态-&gt;阻塞状态: I/O请求；</li>
<li>阻塞状态-&gt;就绪状态: I/O完成。</li>
</ul>
</li>
<li><p>PV操作</p>
<ul>
<li>概念:PV操作与信号量的处理相关，P表示通过的意思，V表示释放的意思。</li>
<li>所谓信号灯，实际上就是用来控制进程状态的一个代表某一资源的存储单元。例如，p1和p2是分别将数据送入缓冲B和从缓冲B读出数据的两个进程，为了防止这两个进程并发时产生错误，Dijkstra设计了一种同步机制叫“PV操作”，P操作和V操作是执行时不被打断的两个操作系统原语。</li>
<li>PV原语:PV操作是典型的同步机制之一。用一个信号量与一个消息联系起来，当信号量的值为0时，表示期望的消息尚未产生</li>
</ul>
</li>
<li><p>经典进程同步问题</p>
<ul>
<li>生产者-消费者问题<ul>
<li>概念:假设有两个共享固定大小缓冲区的线程–即所谓的”生产者”和”消费者”—在实际运行时会发生问题。</li>
<li>问题:生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</li>
<li>解决方法：令生产者在缓冲区满时休眠，等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。 同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。</li>
<li>信号量实现:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">多生产者-多消费者问题</span><br><span class="line">Process Pi(1...m);//生产者</span><br><span class="line">.....</span><br><span class="line">Repeat</span><br><span class="line">//生产一个产品</span><br><span class="line">wait(buffer);</span><br><span class="line">wait(S);</span><br><span class="line">//送产品到Buffer(in)</span><br><span class="line">in=(int+1)mod n;</span><br><span class="line">singal(s);</span><br><span class="line">singal(prod);</span><br><span class="line">Process Pi(1...m);//消费者</span><br><span class="line">.....</span><br><span class="line">Repeat</span><br><span class="line">//生产一个产品</span><br><span class="line">wait(prod);</span><br><span class="line">wait(S);</span><br><span class="line">//送产品到Buffer(in)</span><br><span class="line">out=(out+1)mod N;</span><br><span class="line">singal(s);</span><br><span class="line">singal(buf);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><ul>
<li>作用<br>使一个在多道程序环境下不能独立运行的程序，称为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。</li>
<li><p>结构</p>
<ul>
<li><p>进程标识符</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程标识符用于唯一地标识一个进程。</span><br><span class="line">（1）内部标识符。（方便系统）</span><br><span class="line"> (2) 外部标识符。（方便用户）</span><br></pre></td></tr></table></figure>
</code></pre></li>
<li><p>处理机状态</p>
</li>
<li>进程调度信息  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)进程状态</span><br><span class="line">(2)进程优先级</span><br><span class="line">(3)进程调度所需的其它信息</span><br><span class="line">(4)事件</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>+ 进程控制信息

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)程序和数据的地址</span><br><span class="line">(2)进程同步和通信 机制</span><br><span class="line">(3)资源清单</span><br><span class="line">(4)链接指针</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li>组织方式<ul>
<li>链接方式</li>
<li>索引方式</li>
</ul>
</li>
</ul>
<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h2 id="两种制约关系"><a href="#两种制约关系" class="headerlink" title="两种制约关系"></a>两种制约关系</h2><ul>
<li>间接相互制约关系（共享资源）</li>
<li>直接相互制约关系（合作）</li>
</ul>
<h2 id="同步机制应遵循的规则"><a href="#同步机制应遵循的规则" class="headerlink" title="同步机制应遵循的规则"></a>同步机制应遵循的规则</h2><ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
<h2 id="进程同步机制"><a href="#进程同步机制" class="headerlink" title="进程同步机制"></a>进程同步机制</h2><ul>
<li><p>信号量机制</p>
<ul>
<li>整型信号量</li>
<li>记录型信号量</li>
<li>AND型信号量</li>
<li>信号量集</li>
</ul>
</li>
<li><p>管程机制<br>一个管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据。</p>
<ul>
<li>管程的名称</li>
<li>局部于管程内部的共享数据结构说明</li>
<li>对该数据结构进行操作的一组过程</li>
<li>对局部于管程内部的共享数据设置初始值的语句</li>
</ul>
</li>
</ul>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><ul>
<li>共享存储器系统</li>
<li>消息传递系统</li>
<li>管道通信</li>
</ul>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ul>
<li>属性<ul>
<li>轻型实体<br>  不拥有系统资源，独立tcb，用于指示被执行指令序列的程序计数器，保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈    </li>
<li>可独立调度和分派的基本单位</li>
<li>可并发执行</li>
<li>共享进程资源</li>
</ul>
</li>
<li>实现方式<br>  1.内核支持线程<br>  2.用户级线程</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/01/进程相关/" data-id="cjyshtzrb001akz2xjy8o77av" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统复习/">操作系统复习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-redis源码阅读-整数集合" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/31/redis源码阅读-整数集合/" class="article-date">
  <time class="post-time" datetime="2019-07-31T07:36:31.000Z" itemprop="datePublished">
    <span class="post-month">7月</span><br>
    <span class="post-day">31</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/31/redis源码阅读-整数集合/">redis源码阅读-整数集合</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis源码阅读/">redis源码阅读</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>redis中整数集合（intset）用于有序、无重复地保存多个整数值， 根据元素的值，自动选择该用什么长度的整数类型来保存元素。</p>
<h2 id="intset的结构体"><a href="#intset的结构体" class="headerlink" title="intset的结构体"></a>intset的结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure>
<p>在这个结构体中encoding用来保存元素所使用的类型的长度，length用来保存元素个数，contents保存实际的数据。有意思的是，对于int8_t，实际上contents保存的类型根据实际需要为数据中最大的类型，int8_t在此仅仅作为占位符。</p>
<h2 id="intset的函数"><a href="#intset的函数" class="headerlink" title="intset的函数"></a>intset的函数</h2><p>定义在intset结构体中的函数或者说可以对其所做的操作涉及以下几种：<br>|函数签名|作用|<br>:-:|:-:<br>|intset <em>intsetNew(void)|创建一个新的intset|<br>|intset </em>intsetAdd(intset <em>is, int64_t value, uint8_t </em>success)|增添一个新的整数元素|<br>|intset <em>intsetRemove(intset </em>is, int64_t value, int <em>success)|删除一个元素|<br>|uint8_t intsetFind(intset </em>is, int64_t value)|检查给定值是否存在于集合|<br>|int64_t intsetRandom(intset <em>is)|从整数集合中随机返回一个元素|<br>|uint8_t intsetGet(intset </em>is, uint32_t pos, int64_t <em>value)|获取元素|<br>|uint32_t intsetLen(const intset </em>is)|元素个数|<br>|size_t intsetBlobLen(intset *is)|返回整数集合占用的内存字节数|</p>
<h2 id="intset的主要运行"><a href="#intset的主要运行" class="headerlink" title="intset的主要运行"></a>intset的主要运行</h2><h3 id="创建一个新的整数集合"><a href="#创建一个新的整数集合" class="headerlink" title="创建一个新的整数集合"></a>创建一个新的整数集合</h3><p><strong> intset *is = intsetNew() </strong></p>
<p>当创建一个新的整数集合时，其默认将encoding赋值为_int16的大小，length设置为0。</p>
<h3 id="添加新元素到-intset"><a href="#添加新元素到-intset" class="headerlink" title="添加新元素到 intset"></a>添加新元素到 intset</h3><p>当将元素添加到整数集合中时，其需要考虑以下情形：</p>
<ol>
<li>元素已存在于集合，不做动作；</li>
<li>元素不存在于集合，并且添加新元素并不需要升级；</li>
<li>元素不存在于集合，但是要在升级之后，才能添加新元素；<br>而且，intsetAdd 需要维持元素内容的以下性质：<br>确保数组中没有重复元素；<br>确保数组中的元素按由小到大排序；</li>
</ol>
<p>所以添加元素函数intsetAdd的主要流程步骤可以如下：</p>
<div id="flowchart-0" class="flow-chart"></div>

<h3 id="添加新元素到-intset-需要升级"><a href="#添加新元素到-intset-需要升级" class="headerlink" title="添加新元素到 intset(需要升级)"></a>添加新元素到 intset(需要升级)</h3><p>接下来详细，看下当需要对contens进行升级时intsetAdd函数进行的操作。<br>该操作主要由intsetUpgradeAndAdd函数进行。</p>
<p>该函数的主要任务为：<br>1.对新元素进行检测，看保存的新元素需要什么类型编码；<br>2.将集合encoding属性的值设置为新编码类型，并根据新编码类型，对整个contetns数组进行内存重分配；<br>3.调整contents数组内原有元素在内存中的排列方式，从旧编码调整为新编码。<br>4.将新元素添加到集合中。</p>
<p>此处重点考虑下理解将旧的编码更改为新的编码。</p>
<p>假设有个intset，有三个用int16_t方式保存的数值，分别是1、2和3，结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intset-&gt;contents = [1,2,3];</span><br></pre></td></tr></table></figure></p>
<p>内存排列如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bit   0     15     31     47</span><br><span class="line">value    1      2      3</span><br></pre></td></tr></table></figure></p>
<p>将一个长度为int32_t的值 65535加入到集合中。<br>1.将encoding设置。<br>2.根据encoding属性的值，对contents数组进行内存重分配。<br>重分配后，contents在内存中的排列如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bit   0     15     31     47     63     95    127</span><br><span class="line">value    1      2      3</span><br></pre></td></tr></table></figure></p>
<p>contens数组现在有4个int32_t值的空间。<br>3.因为原来的3个int16_t值还“挤在”contents前面的48个位里，所以程序需要移动它们并转换类型，让它们适应集合的新编码方式。<br>4.移除后，将新值65535添加到数组。</p>
<p>###升级有两个原则</p>
<ul>
<li>从较短整数到较长整数的转换，并不会更改元素里面的值</li>
<li>集合编码元素的方式，由元素中长度最大的那个值来决定</li>
</ul>
<p>##总结</p>
<ul>
<li>Intset 用于有序、无重复地保存多个整数值，会根据元素的值，自动选择该用什么长度的整数类型来保存元素。</li>
<li>当一个位长度更长的整数值添加到 intset 时，需要对 intset 进行升级，新 intset 中每个元素的位长度，会等于新添加值的位长度，但原有元素的值不变。</li>
<li>升级会引起整个 intset 进行内存重分配，并移动集合中的所有元素，这个操作的复杂度为 O(N) 。</li>
<li>Intset 只支持升级，不支持降级。</li>
<li>Intset 是有序的，程序使用二分查找算法来实现查找操作，复杂度为 O(lgN)<br><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始
cond1=>condition: 实际值长度大于intset的值长度
op1=>operation: 对contents进行类型升级后插入值
cond2=>condition: 判断元素是否重复
op2=>operation: 为新元素分配内存，并对contents数组中现有的元素进行移动，确保新元素会被放到有序数组正确的位置
op3=>operation: 将新元素的值保存到contents数组中更新lenght计数器
op4=>operation: 添加失败
ed=>end: 结束

st->cond1
cond1(yes)->op1->ed
cond1(no)->cond2
cond2(yes)->op4->ed
cond2(no)->op2->op3->ed</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/31/redis源码阅读-整数集合/" data-id="cjyshtzr80012kz2xzlbuatga" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-redis源码阅读-跳跃表" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/02/redis源码阅读-跳跃表/" class="article-date">
  <time class="post-time" datetime="2019-06-02T04:20:12.000Z" itemprop="datePublished">
    <span class="post-month">6月</span><br>
    <span class="post-day">02</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/02/redis源码阅读-跳跃表/">redis源码阅读--跳跃表</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis源码阅读/">redis源码阅读</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于跳跃表之前已经简单说明了下，那么redis的跳跃表又是如何实现应用的呢？这次就来看看。</p>
<h2 id="redis跳跃表的实现"><a href="#redis跳跃表的实现" class="headerlink" title="redis跳跃表的实现"></a>redis跳跃表的实现</h2><p>数据结构定义：(server.h/zskiplist)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">//头节点，尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">//节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">//目前表内节点的最大层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure></p>
<p>节点定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">//分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//后退指针，用于从表尾方向向表头方向迭代：当需要逆序处理有序集的命令时，就会用到这个属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">//层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></p>
<h2 id="redis跳跃表的应用"><a href="#redis跳跃表的应用" class="headerlink" title="redis跳跃表的应用"></a>redis跳跃表的应用</h2><p>跳跃表在redis中的唯一作用，就是实现有序集数据类型。跳跃表将指向有续集的score值和meber域的指针作为元素，并且以score值作为索引，对有序元素进行排序。<br>举例子来说：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD s <span class="number">6</span> x <span class="number">10</span> y <span class="number">15</span> z</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">redisZRANGE s <span class="number">0</span><span class="number">-1</span> WITHSCORES</span><br></pre></td></tr></table></figure></p>
<p>在redis的底层实现中，其为x、yh和z三个member分别创建了三个字符串，值分别为double类型的6，10，和15，然后用跳跃表将这些指针有序地保存起来，形成这样一个跳跃表：<br><img src="http://static.zybuluo.com/yiranblade/dfg1p2u8qtk9ib99ywg02xu4/image.png" alt="image.png-35.8kB"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>redis的跳跃表是一种随机化的数据结构，查找、添加、删除操作都可以在对数期望时间下完成。</li>
<li>跳跃表目前在redis的唯一作用，就是作为有序集类型的底层数据结构（另一个是字典）。</li>
<li>为了满足自身需要，redis基于william pugh 论文中的描述的跳跃表进行了修改，包括:<br>  1.score值可重复。<br>  2.对比一个元素与同时需要检查它的score和member。<br>  3.每个节点带有高度为1层的后退指针，用于从表尾方向向表头方向迭代。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/02/redis源码阅读-跳跃表/" data-id="cjyshtzr70010kz2x4p7yf21p" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-理解跳跃表" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/21/理解跳跃表/" class="article-date">
  <time class="post-time" datetime="2019-05-21T09:15:06.000Z" itemprop="datePublished">
    <span class="post-month">5月</span><br>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/21/理解跳跃表/">理解跳跃表</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构与算法/">数据结构与算法</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>好久没碰过数据结构了，在看redis源码时看到跳跃表的结构，不禁又回想起大学毕业面试被问到跳表的一脸尴尬，于是这次就好好的将对跳表的理解整理下吧。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>跳跃表是一种数据结构。其允许快速查询一个有序连续元素的数据链表。而且跳跃列表的平均查找和插入时间复杂度都是O(log n)，比常用的线性结构链表，数组这类的时间复杂度O(n)要优秀很多。<br>其结构如图所示：<br><img src="http://static.zybuluo.com/yiranblade/f091k5dmlz778f01tu9ov96i/image.png" alt="image.png-61kB"><br><strong>每个带有箭头的框表示一个指针, 而每行是一个稀疏子序列的链表；底部的编号框（黄色）表示有序的数据序列。查找从顶部最稀疏的子序列向下进行, 直至需要查找的元素在该层两个相邻的元素中间。</strong></p>
<p>##增加元素<br>对于跳跃表来说，当向表中增加一个元素时其会通过最顶层的索引一层层往下找，由于建立索引的关键节点几乎是下一层的一半，所以在查找索引的过程需要比较的元素数目相比于直接去查找源链表一次会减少一半的查询次数，即总的时间复杂度会为O(log n)。<br>具体过程是这样的：</p>
<div id="flowchart-0" class="flow-chart"></div>

<p>##删除元素<br>跳跃表删除元素的操作是这样的，自上而下，查找第一次出现节点的索引，并逐层找到每一层对应的节点。删除每一层查找到的节点，如果该层只剩下1个节点，删除整个一层（原链表除外）。总体上，跳跃表删除操作的时间复杂度是O（logN）。<br>![image.png-79.1kB][2]</p>
<p>5为需要删除的节点。</p>
<p>##总结<br>跳表的结构定义：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ype head <span class="keyword">struct</span> &#123;</span><br><span class="line">	length <span class="keyword">int</span></span><br><span class="line">	next   *skipNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> skipNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">int</span></span><br><span class="line">	next  *skipNode</span><br><span class="line">	high  *skipNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> skipTable <span class="keyword">struct</span> &#123;</span><br><span class="line">	table []*head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于跳表其实可以使用一个指针数组保存每一级别的头节点，每个元素节点存在两个指针一个指向链表的下一个元素一个指向上级索引这种方式来实现。查找和修改的操作基本步骤和上面的删除添加差不多。我们日常熟悉的redis中也有对其使用，相比于平衡树其具有易于维护的特点。</p>
<p>  [2]: <a href="http://static.zybuluo.com/yiranblade/rrgrlex0unc20o563pgdmhki/image.png" target="_blank" rel="noopener">http://static.zybuluo.com/yiranblade/rrgrlex0unc20o563pgdmhki/image.png</a><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始
input=>inputoutput: 待增加节点
op1=>operation: 查找第一层索引
op2=>operation: 查找到后继续下一层索引
op3=>operation: 直到找到相应位置
op4=>operation: 插入该节点，抛硬币决定该节点是否要提升一层索引
ed=>end: 结束

st->input->op1->op2->op3->op4->ed</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/21/理解跳跃表/" data-id="cjyshtzrc001ekz2xw7sjmddm" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/跳表/">跳表</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-redis源码阅读-字典" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/11/redis源码阅读-字典/" class="article-date">
  <time class="post-time" datetime="2019-05-11T13:05:38.000Z" itemprop="datePublished">
    <span class="post-month">5月</span><br>
    <span class="post-day">11</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/11/redis源码阅读-字典/">redis源码阅读--字典</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis源码阅读/">redis源码阅读</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>字典又叫映射或者说关联数组，是一种抽象的数据结构。本节主要来分析下它的源码。关于map应该说都是挺熟悉的数据结构了。</p>
<h2 id="redis中字典的应用"><a href="#redis中字典的应用" class="headerlink" title="redis中字典的应用"></a>redis中字典的应用</h2><p>redis字典的用途有以下两个：<br>1.实现数据库键空间；<br>2.用作hash类型键的底层实现之一；</p>
<h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>实现字典的方法有很多种：</p>
<ul>
<li>使用链表和数组</li>
<li>使用哈希表</li>
<li>平衡树</li>
</ul>
<p>在redis种使用哈希表作为字典的底层实现。<br>其结构如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p>
<p><strong>0号哈希表是字典主要使用的哈希表，1号哈希表则只有在程序对0号哈希表rehash时使用。</strong></p>
<h3 id="哈希表实现"><a href="#哈希表实现" class="headerlink" title="哈希表实现"></a>哈希表实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表节点指针数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//指针数组大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//指针数组长度的掩码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//哈希表现有的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<p>table 属性是个数组， 数组的每个元素都是个指向 dictEntry 结构的指针。</p>
<p>每个 dictEntry 都保存着一个键值对， 以及一个指向另一个 dictEntry 结构的指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure></p>
<p>next属性指向另一个dictEntry结构，多个dictEntry可以通过next指针串连成链表，所以dictht使用链地址法来处理键碰撞：当多个不同的键拥有相同的哈希值时，哈希表用一个链表将这些键连接起来。结构如下：<br><img src="http://static.zybuluo.com/yiranblade/egppkusmd2euuunulsin9scl/image.png" alt="image.png-43kB"></p>
<p>所以整个字典结构如下：<br><img src="http://static.zybuluo.com/yiranblade/nwy6hgtibqxjqlu82w6hjgrt/image.png" alt="image.png-69.6kB"></p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>redis目前使用两种不同的哈希算法：</p>
<ul>
<li>MurmurHash2 32 bit 算法：这种算法的分布率和速度都非常好</li>
<li>基于 djb 算法实现的一个大小写无关散列算法</li>
</ul>
<h3 id="dictCreate函数"><a href="#dictCreate函数" class="headerlink" title="dictCreate函数"></a>dictCreate函数</h3><p>dictCreate函数创建并返回一个新字典：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict *d = dictCreate(&amp;hash_type, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://static.zybuluo.com/yiranblade/0vd7w99sk5reddrvodwlraau/image.png" alt="image.png-37.4kB"><br>新创建的哈希表都没有为table属性分配任何空间:</p>
<ul>
<li>ht[0]-&gt;table 的空间分配将在第一次往字典添加键值对时进行；</li>
<li>ht<a href="http://static.zybuluo.com/yiranblade/egppkusmd2euuunulsin9scl/image.png" target="_blank" rel="noopener">1</a>-&gt;table 的空间分配将在rehash开始时进行;</li>
</ul>
<h3 id="添加键值对到字典"><a href="#添加键值对到字典" class="headerlink" title="添加键值对到字典"></a>添加键值对到字典</h3><p>根据字典所处的状态，将给定的键值对添加到字典会引起一系列复杂的操作:</p>
<ul>
<li>如果字典未初始化（即字典的0号哈希表的table属性为空），则程序需要对0号哈希表进行初始化；</li>
<li>如果在插入时发生了键碰撞，则程序需要处理碰撞；</li>
<li>如果插入新元素，使得字典满足了rehash条件，则需要启动rehash程序</li>
</ul>
<p>当程序处理完以上三种情况之后，新的键值对才会被真正地添加到字典上。<br>整个添加流程如下：<br><img src="http://static.zybuluo.com/yiranblade/r2py7a1mfcjqtwksm3z4phqa/image.png" alt="image.png-140.7kB"></p>
<h4 id="添加新元素到空白字典"><a href="#添加新元素到空白字典" class="headerlink" title="添加新元素到空白字典"></a>添加新元素到空白字典</h4><p>当第一次往空字典里添加键值对时，程序会根据dict.h/DICT_HT_INITIAL_SIZE里指定的大小为d-&gt;ht[0]-&gt;table分配空间（目前这个值是4）</p>
<ul>
<li>字典空白<br><img src="http://static.zybuluo.com/yiranblade/m6rtl5ieut5u2jx8sgdg8g1y/image.png" alt="image.png-37.4kB"></li>
<li>往字典添加了第一个键值对之后<br><img src="http://static.zybuluo.com/yiranblade/lqvjzrryxo6g3qq75m2tz0yk/image.png" alt="image.png-59.3kB"></li>
</ul>
<h4 id="添加新键值对时发生碰撞处理"><a href="#添加新键值对时发生碰撞处理" class="headerlink" title="添加新键值对时发生碰撞处理"></a>添加新键值对时发生碰撞处理</h4><p>在哈希表实现中，当两个不同的键拥有相同的哈希值时，称这两个键发生碰撞，而哈希表必须要对碰撞进行处理。字典哈希表所使用的碰撞解决方法被称之为链地址法：这种方法使用链表将多个哈希值相同的节点串连在一起，从而解决冲突问题。</p>
<h4 id="添加新键值对时触发了rehash操作"><a href="#添加新键值对时触发了rehash操作" class="headerlink" title="添加新键值对时触发了rehash操作"></a>添加新键值对时触发了rehash操作</h4><p>对于使用链地址法来解决碰撞问题的哈希表dictht来说，哈希表的性能取决于大小（size属性）与保存节点数量（used属性）之间的比率：</p>
<ul>
<li>哈希表的大小与节点数量，比率在1:1时，哈希表的性能最好；</li>
<li>如果节点数量比哈希表的大小要大很多的话，哈希表就会退化称多个链表，哈希表本身的性能优势便不复存在；</li>
</ul>
<p>所以为了在字典的键值对不断增多的情况下保持良好的性能，字典需要对所使用的哈希表（ht[0]）进行rehash操作:在不修改任何键值对的情况下，对哈希表进行扩容，将比率维持在1:1左右。<br>dictAdd在每次向字典添加新键值对之前，都会对哈希表ht[0]进行检查，对于ht[0]的size和used属性，如果它们之间的比率ratio=used/size满足以下任何一个条件的话，rehash过程就会被激活：</p>
<ol>
<li>自然 rehash ： ratio &gt;= 1 ，且变量 dict_can_resize 为真。</li>
<li>强制 rehash ： ratio 大于变量 dict_force_resize_ratio（目前版本中， dict_force_resize_ratio的值为 5 ）。</li>
</ol>
<h4 id="Rehash执行过程"><a href="#Rehash执行过程" class="headerlink" title="Rehash执行过程"></a>Rehash执行过程</h4><p>字典的rehash操作实际上就是执行以下任务:</p>
<ol>
<li>创建一个比ht[0]-&gt;table更大的ht<a href="http://static.zybuluo.com/yiranblade/egppkusmd2euuunulsin9scl/image.png" target="_blank" rel="noopener">1</a>-&gt;table；</li>
<li>将ht[0]-&gt;table中的所有键值对迁移到ht<a href="http://static.zybuluo.com/yiranblade/egppkusmd2euuunulsin9scl/image.png" target="_blank" rel="noopener">1</a>-&gt;table;</li>
<li>将原有ht[0]的数据清空，并将ht<a href="http://static.zybuluo.com/yiranblade/egppkusmd2euuunulsin9scl/image.png" target="_blank" rel="noopener">1</a>替换为新的ht[0]；</li>
</ol>
<p>经过以上步骤，程序就在不改变原有键值对数据的基础上，增大了哈希表的大小。</p>
<h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>rehash程序并不是在激活之后，就马上执行直到完成的，而是多次、渐进式地完成。<br>redis完成渐进式rehash主要由_dictRehashStep和dictRehashMilliseconds两个函数进行：</p>
<ul>
<li>_dictRehashStep用于对数据库字典、以及哈希键的字典进行被动rehash；</li>
<li>dictRehashMilliseconds则由Redis服务器常规任务程序执行，用于对数据库字典进行主动rehash；</li>
</ul>
<p><strong>_dictRehashStep</strong><br>每次执行_dictRehahshStep，ht[0]-&gt;table哈希表第一个不为空的索引上的所有节点就会全部迁移到ht<a href="http://static.zybuluo.com/yiranblade/egppkusmd2euuunulsin9scl/image.png" target="_blank" rel="noopener">1</a>-&gt;table。<br><strong>dictRehashMilliseconds</strong><br>dictRehashMilliseconds可以在指定的毫秒数内，对字典进行rehash。<br>当Redis的服务器常规任务执行时，dictRehashMilliseconds就会被执行，在规定的时间内，尽可能对数据库字典中那些需要rehash的字典进行rehash，从而加速数据库字典的rehash进程。</p>
<p><strong>因为在rehash时，字典会同时使用两个哈希表，所以在这期间的所有查找、删除等操作，除了在ht[0]进行，还会在ht<a href="http://static.zybuluo.com/yiranblade/egppkusmd2euuunulsin9scl/image.png" target="_blank" rel="noopener">1</a>进行。在执行添加操作时，新的节点会直接添加到ht<a href="http://static.zybuluo.com/yiranblade/egppkusmd2euuunulsin9scl/image.png" target="_blank" rel="noopener">1</a>而不是ht[0]，这样保证ht[0]的节点数量在整个rehash过程中都只减不增。</strong></p>
<h4 id="字典的收缩"><a href="#字典的收缩" class="headerlink" title="字典的收缩"></a>字典的收缩</h4><p>对hash表进行收缩的过程与增加几乎一样；</p>
<ol>
<li>创建一个比ht[0]-&gt;table小的ht<a href="http://static.zybuluo.com/yiranblade/egppkusmd2euuunulsin9scl/image.png" target="_blank" rel="noopener">1</a>-&gt;table;</li>
<li>将ht[0]-&gt;table中的所有键值对迁移到ht<a href="http://static.zybuluo.com/yiranblade/egppkusmd2euuunulsin9scl/image.png" target="_blank" rel="noopener">1</a>-&gt;table；</li>
<li>将原有ht[0]数据清空，并将ht<a href="http://static.zybuluo.com/yiranblade/egppkusmd2euuunulsin9scl/image.png" target="_blank" rel="noopener">1</a>替换为新的ht[0];</li>
</ol>
<h3 id="字典的迭代"><a href="#字典的迭代" class="headerlink" title="字典的迭代"></a>字典的迭代</h3><p>字典拥有其自己的迭代器实现—对字典进行迭代实际上就是对字典所使用的哈希表进行迭代：</p>
<ul>
<li>迭代器首先迭代字典的第一个哈希表，然后，如果rehash正在进行的话，就继续对第二个哈希表进行迭代。</li>
<li>当迭代哈希表时，找到第一个不为空的索引，然后迭代这个索引上的所有节点。</li>
<li>当这个索引迭代完了，继续查找下一个不为空的索引，如此反覆，直到整个哈希表都迭代完为止。</li>
</ul>
<p>字典的迭代器有两种：</p>
<ul>
<li>安全迭代器：在迭代过程中，可以对字典进行修改。</li>
<li>不安全迭代器：在迭代过程中，不可以对字典进行修改。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>字典是由键值对构成的抽象数据结构</li>
<li>Redis中的数据库和哈希键都基于字典来实现</li>
<li>Redis字典的底层实现为哈希表，每个字典使用两个哈希表，一般情况下只使用0号哈希表，只有在rehash进行时，才会使用0号和1号哈希表。</li>
<li>哈希表使用链地址法来解决键冲突的问题。</li>
<li>Rehash可以用于扩展或收缩哈希表。</li>
<li>对哈希表的rehash是分多次、渐进式地进行的</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/11/redis源码阅读-字典/" data-id="cjyshtzs0002fkz2x4pocvpz8" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-redis源码阅读-双端链表" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/27/redis源码阅读-双端链表/" class="article-date">
  <time class="post-time" datetime="2019-04-27T05:06:38.000Z" itemprop="datePublished">
    <span class="post-month">4月</span><br>
    <span class="post-day">27</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/27/redis源码阅读-双端链表/">redis源码阅读--双端链表</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis源码阅读/">redis源码阅读</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>em….链表是一种常用的数据结构。双端链表也是比较熟悉的了，redis的实现还是有必要研究一下的。</p>
<h2 id="redis中双端链表的应用"><a href="#redis中双端链表的应用" class="headerlink" title="redis中双端链表的应用"></a>redis中双端链表的应用</h2><h3 id="redis的列表类型"><a href="#redis的列表类型" class="headerlink" title="redis的列表类型"></a>redis的列表类型</h3><p>双端lian链表是redis列表类型的底层实现之一，当对列表类型的键进行操作–例如rpush、lpop或者llen等命令，程序在底层操作的<strong>可能</strong>就是双端链表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//这里之所以使用“可能”，是因为redis的列表其实使用两种数据结构作为底层实现：</span><br><span class="line">//1. 双端链表</span><br><span class="line">//2. 压缩列表</span><br><span class="line">//因为双端链表占用的内存比压缩列表要多，所以当创建新的列表键时，列表会优先考虑使用压缩列表作为底层实现，并且在有需要的时候，才会从压缩列表实现转换到双端列表的实现。</span><br></pre></td></tr></table></figure></p>
<h3 id="redis自身功能"><a href="#redis自身功能" class="headerlink" title="redis自身功能"></a>redis自身功能</h3><p>除了实现列表类型，双端链表还被redis内部模块所应用：</p>
<ul>
<li>事务模块使用双端列表依序保存输入的命令</li>
<li>服务器模块使用双端链表来保存多个客户端</li>
<li>订阅/发送模块使用双端列表来保存订阅模式的多个客户端</li>
<li>事件模块使用双端链表来保存时间事件</li>
</ul>
<h2 id="双端链表的实现"><a href="#双端链表的实现" class="headerlink" title="双端链表的实现"></a>双端链表的实现</h2><p>双端链表的实现由list和listNode这两个数据结构构成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line">    struct listNode *prev;</span><br><span class="line">    struct listNode *next;</span><br><span class="line">    void *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line">typedef struct list &#123;</span><br><span class="line">    listNode *head; //表头指针</span><br><span class="line">    listNode *tail; //表尾指针</span><br><span class="line">    void *(*dup)(void *ptr); //复制函数</span><br><span class="line">    void (*free)(void *ptr); //释放函数</span><br><span class="line">    int (*match)(void *ptr, void *key);//比对函数</span><br><span class="line">    unsigned long len; //节点数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的void表示双端列表对于节点保存的值的类型不做限制。<br>从数据结构的定义中可以看出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ list的遍历可以双向进行</span><br><span class="line">+ list对链表头和表尾进行插入的复杂度都为0(1)---从而可以做到高效实现lpush，rpop，rpoplpush等命令</span><br><span class="line">+ list带有保存节点数量的len属性，所以计算链表长度的复杂度仅为0（1），和之前sds一样读取长度不会成为性能瓶颈。</span><br></pre></td></tr></table></figure></p>
<p>操作双端链表的函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listEmpty</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span>;</span><br><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listJoin</span><span class="params">(<span class="built_in">list</span> *l, <span class="built_in">list</span> *o)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>redis还为双端链表实现了一个迭代器，这个迭代器可以从两个方向对双端列表进行迭代：</p>
<ul>
<li>沿着next指针前进，从表头到表尾</li>
<li>沿着节点的prev指针前进，从表尾向表头</li>
</ul>
<p>定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_HEAD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_TAIL 1</span></span><br></pre></td></tr></table></figure></p>
<p>其中，direction记录迭代从哪里开始，AL_START_HEA表示从表头开始，AL_START_TAIL 1表示从表尾开始。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>redis实现了自己的双端链表，其主要的作用用来作为redis列表类型的底层实现以及作为通用数据结构，被其他功能模块所使用。总体来说，这部分的代码不是很复杂，基本的实现都是当初学习c语言实现过的一些类似的东西，但是redis的设计者为其加上一点点额外的东西感觉就可以使得这些熟悉的东西变得灵活又作用强大，比如那个len字段的设计，看起来好像挺理所应当，但是在开始设计时，确实很难意识到这一点，往往看到别人的代码这样用才恍然大悟，所以学习的道路还很漫长。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/27/redis源码阅读-双端链表/" data-id="cjyshtzr6000vkz2xwgybfi3l" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-redis源码阅读-动态字符串" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/20/redis源码阅读-动态字符串/" class="article-date">
  <time class="post-time" datetime="2019-04-20T10:20:11.000Z" itemprop="datePublished">
    <span class="post-month">4月</span><br>
    <span class="post-day">20</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/20/redis源码阅读-动态字符串/">redis源码阅读--动态字符串</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis源码阅读/">redis源码阅读</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于char<em>类型的功能单一，抽象层次比较低，且无法高效支持一些Redis常用的操作（追加操作和长度计算操作），所以redis内部程序大多数时候会使用sds动态字符串类型而并不是char</em>表示。</p>
<h2 id="Redis中的字符串"><a href="#Redis中的字符串" class="headerlink" title="Redis中的字符串"></a>Redis中的字符串</h2><p>c语言中，字符串本质为一个使用\0结尾的char数组来表示。<br>但是这种形式无法支持长度计算和追加操作：</p>
<ul>
<li>每次计算字符串长度的复杂度为O(N)</li>
<li>对字符串进行N次追加，必定需要对字符串进行N次内存重分配</li>
</ul>
<p>但是在redis内部，字符串的追加长度和长度计算很常见，而APPEND和STRLEN更是这两种操作，在Redis命令中的直接映射，这两个简单的操作不应该成为性能的瓶颈。而且，Redis除了处理C字符串之外，还需要处理单纯的字节数组，以及服务器协议等，所以为了方便与安全，Redis的字符串表示应该是二进制安全的：程序不应该对字符串里面保存的数据做任何假设，即数据可以是以\0结尾的C字符串，也可以是单纯的字节数组，或者其他格式的数据。<br>基于此，Redis使用sds类型替换了C语言的默认字符串表示：sds既可以高效地追加和长度计算，同时也是二进制安全的。</p>
<h2 id="sds实现"><a href="#sds实现" class="headerlink" title="sds实现"></a>sds实现</h2><p>sds实现主要由两部分构成，第一部分是单纯的c中的char*:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br></pre></td></tr></table></figure></p>
<p>第二部分则为其涉及的具体sds数据类型，一共有5种：</p>
<table>
<thead>
<tr>
<th style="text-align:center">结构体类型</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sdshdr5</td>
<td style="text-align:center">保存5位长度字符串（不再使用）</td>
</tr>
<tr>
<td style="text-align:center">sdshdr8</td>
<td style="text-align:center">保存8位长度字符串</td>
</tr>
<tr>
<td style="text-align:center">sdshdr16</td>
<td style="text-align:center">保存16位长度字符串</td>
</tr>
<tr>
<td style="text-align:center">sdshdr32</td>
<td style="text-align:center">保存32位长度字符串</td>
</tr>
<tr>
<td style="text-align:center">sdshdr64</td>
<td style="text-align:center">保存64位长度字符串</td>
</tr>
</tbody>
</table>
<p>在这些结构中整体都可以提取为以下几个字段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    len ; </span><br><span class="line">    alloc ;</span><br><span class="line">    buf[] ;</span><br><span class="line">    flags ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这三个字段所表示的含义为：len代表buf的字符串长度，alloc代表整体的分配空间，buf为实际保存字符串数据的地方，flags保存了字符串的具体数据类型。<br>整体来看，我们就可以这样去理解整个sds的结构，类型sds是char*的别名，而结构sdshdr则保存了len、alloc、buf、flags四个属性。<br>使用这个结构来保存helloworld：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line">    len = 11;</span><br><span class="line">    alloc = 11;</span><br><span class="line">    buf = &#123;&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;,&apos;w&apos;,&apos;o&apos;,&apos;r&apos;,&apos;l&apos;,&apos;d&apos;,&apos;\0&apos;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由此我们就可以理解，redis是怎么优化读取len的速度了。直接读取sdslen属性就可以实现时间复杂度为θ(1) 的长度计算操作。另一点，通过对buf分配一些额外的空间，sdshdr 可以让执行追加操作所需的内存重分配次数大大减少。</p>
<h2 id="字符串追加操作的优化"><a href="#字符串追加操作的优化" class="headerlink" title="字符串追加操作的优化"></a>字符串追加操作的优化</h2><p>其实由前面的结构已经可以看出来了，这里实际上是redis在执行append操作时会进行一个内存预先分配的策略，如果内存足够就无需再次分配内存从而提高效率，减少重新分配内存的策略。这个套路好多编程语言软件在其动态数组或者说线性表的结构都会使用，java中的List,Go中的切片等等都有使用。<br>redis这里sds的分配策略实际是通过sdsMakeRoomFor这个函数来实现的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can't use realloc */</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, newlen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总体整理下该函数所作的操作为，首先获取剩余内存空间长度，如果剩余内存足够使用，则返回无需进行分配。需要新分配空间时计算新字符串所需的总长度，如果其长度小于SDS_MAX_PREALLOC那么为字符串分配2倍于所需长度的空间，否则就分配所需长度加上SDS_MAX_PREALLOC数量的空间。最后的一系列操作就是确认新的sds类型重新分配空间。<br><strong>在目前版本的 Redis 中， SDS_MAX_PREALLOC 的值为 1024 * 1024 ， 也就是说， 当大小小于 1MB 的字符串执行追加操作时， sdsMakeRoomFor 就为它们分配多于所需大小一倍的空间； 当字符串的大小大于 1MB ， 那么 sdsMakeRoomFor 就为它们额外多分配 1MB 的空间。</strong></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>对于redis来说，其内部字符串的实现采用sds来实现。我们从sds这一内部结构开始阅读redis的源代码，其数据类型结构部分与其余地方耦合度比较少，阅读起来还是比较容易的。<br>总结一下，sds大概的特点如下：</p>
<ul>
<li>Redis 的字符串表示为 sds ，而不是 C 字符串（以 \0 结尾的 char*）。</li>
<li>对比 C 字符串， sds 有以下特性：<ul>
<li>可以高效地执行长度计算（strlen）；</li>
<li>可以高效地执行追加操作（append）；</li>
<li>二进制安全；</li>
</ul>
</li>
<li>sds 会为追加操作进行优化：加快追加操作的速度，并降低内存分配的次数，代价是多占用了一些内存，而且这些内存不会被主动释放。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/20/redis源码阅读-动态字符串/" data-id="cjyshtzr3000pkz2x70aq2lpp" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-垃圾代码重构-《代码整洁之道》-读后感" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/14/垃圾代码重构-《代码整洁之道》-读后感/" class="article-date">
  <time class="post-time" datetime="2019-04-14T12:38:19.000Z" itemprop="datePublished">
    <span class="post-month">4月</span><br>
    <span class="post-day">14</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/14/垃圾代码重构-《代码整洁之道》-读后感/">垃圾代码重构-《代码整洁之道》-读后感</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/《代码整洁之道》读书笔记/">《代码整洁之道》读书笔记</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>根据作者的说法，该书大致上分为3个部分。第一部分主要介绍编写整洁代码的原则、模式和实践。第二部分结合实际的例子教导我们如何使用这些原则。第三部分则重点介绍得到的启示与灵感。目前的话我应该是读完了第一部分以及第二部分的一半左右，但是仅仅这部分的内容感觉就已经获益匪浅，在此记录一下。</p>
<h2 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h2><p>这一点，在我不长的编程生涯中，体会不可谓不深。截取一段自己在大学阶段项目里的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class LoginServiceImpl implements LoginService&#123;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private UserMapper userDao;</span><br><span class="line">	</span><br><span class="line">	@Autowired</span><br><span class="line">	private UserInfoMapper userInfoDao;</span><br><span class="line">	</span><br><span class="line">	public UserDto login(String username, String password) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		UserDto userDto=new UserDto();</span><br><span class="line">		User user=userDao.LoginService(username, password);</span><br><span class="line">		UserInfo userInfo=null;</span><br><span class="line">		if(user!=null)&#123;</span><br><span class="line">			userInfo=userInfoDao.selectByUserName(user.getUserName());</span><br><span class="line">			userDto.setUserName(user.getUserName());</span><br><span class="line">			userDto.setRole(user.getRole());</span><br><span class="line">			userDto.setDepartment(userInfo.getDepartment());</span><br><span class="line">			userDto.setEmail(userInfo.getEmail());</span><br><span class="line">			userDto.setName(userInfo.getName());</span><br><span class="line">			userDto.setCreateTime(userInfo.getCreateTime());</span><br><span class="line">			userDto.setUserId(userInfo.getUserId());</span><br><span class="line">			return userDto;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是自己当年上学时某个项目中的一个实现用户登录的逻辑，以现在的眼光或者说现在的经验来看，感觉命名糟糕的一踏糊涂。首先是类的命名，类的命名应该是一个名词，因为一个对象其方法才是具体的行为，在这里我用login作为命名一眼看过去就好像这整个类都在做登录这个动作，但实际上类代表的不是一个动作，这很不面向对象。其次是对象UserDto和userDao也意义不明，一眼看去根本不知道这个类到底是用来干嘛的。所以正如书中说的那样<strong>变量、函数或类的名称应该已经答复了所有的大问题。它应该告诉你，它为什么会存在，它做什么事情，应该怎么用</strong>。<br>还有一点避免使用编码，没有理由要求每位新人都在弄清楚要应付的代码之外，还要再搞懂另一种编码“语言”。感觉自己刚刚进公司就常常犯这种错误，比如xxxList，xxxSet之类的带有鲜明语言特色的东西，其实对阅读代码的人毫无帮助反而徒增了很多负担。在看看下面的一个排序代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;</span><br><span class="line">    int array[5] =&#123;4,2,1,4,5&#125;;</span><br><span class="line">    selectSort(array,5);</span><br><span class="line">    for(int i=0;i&lt;5;j++)&#123;</span><br><span class="line">        printf(&quot;%d&quot;,array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初学编程我们每个人应该都写过这样的排序代码，那在命名层面其有什么不妥呢？首先在代码开头定义的array变量就很意义不明，数组这一单词带有明显的编码色彩。其次是selectSort的函数命名，看起来是要排序，但是select是什么鬼，取出排序？对于函数命名应该言简意赅，意义明确，使用动词表达清其要做的事情，所以这里单纯用sort其实更好。最后是for循环的终止条件5，5这个数字在这段代码中表示什么？它在循环中表示什么的终止？显然这些问题仅仅靠单纯一个数字是没办法回答的。虽然这个程序现在很短小我们结合上下文阅读立马就可以反应过来，这个5是需要排序数组的大小，是待排数据的极值。但是如果程序变得很长很长呢，想象一下，你已经读了100来行代码了，现在又要求你回过头去结合上下文理解这个5的含义，任谁都会吐槽诅咒写的人吧。所以在编码中我们需要将这类意义不明的数字“5”换作一个具有意义的变量来表示其作用职责。<br>对于命名书中还涉及到了很多原则，在此就不做过多展开了，有兴趣可以去翻翻原作。由此看以看出，就单纯一项命名已经很考验编程功底了，所以千万不要胡乱命名给自己他人造成麻烦。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>短小，只做好一件事情。</strong>这是我对书中关于函数部分的最大印象。</p>
<ul>
<li>短小<br>即函数尽量要短，其实这个准则应该最大的好处就是读起来很很简单吧。按照作者的话说就是，每个函数都依序把你带到下一个函数。这就是函数应该达到的短小程度！！！即当我们面对一个长长的函数时，应该对其进行拆分将里面过长的内容拆分成一个个的小函数。这样不仅仅读的人赏心悦目，修改起来也很方便。</li>
<li>只做好一件事<br>个人感觉这条是最难以把握的，因为往往分不清这件事是不是应该这个函数做还是需要单独拆分。比如getStudentInfoById这个函数，根据名称来看应该是通过id获取学生信息，听起来貌似只需要从数据库中拿出学生信息并返回就可以了，但是学生信息还需要各种处理，比如需要有顺序的返回，或者说某些信息需要转换后返回，这些操作看起来与拿这个动作无关，但是确实是属于这个函数的附属品，不可能在函数名称中体现到这么多操作。其实，只要确保函数中的内容都在同一抽象级就好了，刚才说的各种对信息的处理其实可以拆分成使用formatXXX之类的函数完成，那么我们这个getStudentInfoById的函数就一共分为了两步，第一步从数据库拿出学生信息，第二部对其进行格式化。格式化与从数据库拿出这两个操作均在函数的同一抽象层，所以这两个操作都可以看作是为了完成拿出学生准确信息这一操作。</li>
</ul>
<p><strong>判断函数是否不止做了一件事，就是看是否能再拆岀一个函数，该函数不仅只是单纯地重新诠释其实现</strong>。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>这里我就记住一句话，<strong>唯一真正好的注释是你想办法不去写的注释</strong><br>尽量用代码去解释函数、类的行为，带有少量注释的整洁而有表达力的代码，要比大量注释的零碎而复杂的代码像样的多。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>代码格式很重要，感觉作者再书中不断强调这一点。尤其是一个项目团队大家都应当按照相同的格式去编写代码，这样有利于维护代码。从上往下的垂直格式总是必要的，还有最外层的文件的抽象概念由外到里依次变得细节。<br>运算符之间加空格区分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b + 2</span><br></pre></td></tr></table></figure></p>
<p>不同的区块也应该分割下，函数开头一般都是变量声明初始化之类的，所以就应该在初始化变量完成后，多一个换行之类的与接下来的代码区分，以此利于阅读。总之不管用什么风格，同一个团队应该保持一致，这样在后续开发中项目整体才比较容易维护，不同人不同的风格就会造成巨大的混乱，最终导致源代码不可读，不可维护。</p>
<h2 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h2><p><strong>当功能点需要常常添加新的结构时使用面向对象，需要常常添加新的方法行为使用面向过程</strong><br>所以说无论是面向对象或者是面向过程都是方法论，业务才是一切，没有永远适合的，只有当前适合的。<br><strong>一切都是对象只是一个传说</strong></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>这个仁者见仁智者见智，我只想说书中关于只使用异常的做法以前我可能会很认同，但最近在使用了go语言之后，对于没有异常处理机制的语言来说只使用异常就不再可能了，所以说看待问题还是不能太死板，没有什么是一成不变的，也没有绝对的真理。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类应该短小，且遵循单一权责原则，即类或者模块应有且只有一条加以修改的理由。<br>类应该只有少量实体变量，类中的每个方法都应该操作一个或多个这种变量，即类要保持内聚性。<br>如果说有很多方法并没有黏聚到类上，又或者为了保持函数和参数列表短小的策略，有时会导致为一组子集方法所用的实体变量数量增加。出现这种情况，就要拆分岀新的类了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/14/垃圾代码重构-《代码整洁之道》-读后感/" data-id="cjyshtzs1002gkz2xfw5cb7rj" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/代码优化/">代码优化</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-go版本shadowsocks源码-终章" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/01/go版本shadowsocks源码-终章/" class="article-date">
  <time class="post-time" datetime="2019-04-01T09:00:52.000Z" itemprop="datePublished">
    <span class="post-month">4月</span><br>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/go版本shadowsocks源码-终章/">go版本shadowsocks源码-终章</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/shadowsocks源码/">shadowsocks源码</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本节我们来看一下shadowsocks-server端的源码。server端相比local端要简单不少，其所做的主要工作就是解码请求并返回结果。</p>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>照例我们从main函数开始分析其大致流程。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.SetOutput(os.Stdout)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> cmdConfig ss.Config</span><br><span class="line">	<span class="keyword">var</span> printVer <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> core <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	flag.BoolVar(&amp;printVer, <span class="string">"version"</span>, <span class="literal">false</span>, <span class="string">"print version"</span>)</span><br><span class="line">	flag.StringVar(&amp;configFile, <span class="string">"c"</span>, <span class="string">"config.json"</span>, <span class="string">"specify config file"</span>)</span><br><span class="line">	flag.StringVar(&amp;cmdConfig.Password, <span class="string">"k"</span>, <span class="string">""</span>, <span class="string">"password"</span>)</span><br><span class="line">	flag.IntVar(&amp;cmdConfig.ServerPort, <span class="string">"p"</span>, <span class="number">0</span>, <span class="string">"server port"</span>)</span><br><span class="line">	flag.IntVar(&amp;cmdConfig.Timeout, <span class="string">"t"</span>, <span class="number">300</span>, <span class="string">"timeout in seconds"</span>)</span><br><span class="line">	flag.StringVar(&amp;cmdConfig.Method, <span class="string">"m"</span>, <span class="string">""</span>, <span class="string">"encryption method, default: aes-256-cfb"</span>)</span><br><span class="line">	flag.IntVar(&amp;core, <span class="string">"core"</span>, <span class="number">0</span>, <span class="string">"maximum number of CPU cores to use, default is determinied by Go runtime"</span>)</span><br><span class="line">	flag.BoolVar((*<span class="keyword">bool</span>)(&amp;debug), <span class="string">"d"</span>, <span class="literal">false</span>, <span class="string">"print debug message"</span>)</span><br><span class="line">	flag.BoolVar((*<span class="keyword">bool</span>)(&amp;sanitizeIps), <span class="string">"A"</span>, <span class="literal">false</span>, <span class="string">"anonymize client ip addresses in all output"</span>)</span><br><span class="line">	flag.BoolVar(&amp;udp, <span class="string">"u"</span>, <span class="literal">false</span>, <span class="string">"UDP Relay"</span>)</span><br><span class="line">	flag.StringVar(&amp;managerAddr, <span class="string">"manager-address"</span>, <span class="string">""</span>, <span class="string">"shadowsocks manager listening address"</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> printVer &#123;</span><br><span class="line">		ss.PrintVersion()</span><br><span class="line">		os.Exit(<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ss.SetDebug(debug)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	config, err = ss.ParseConfig(configFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !os.IsNotExist(err) &#123;</span><br><span class="line">			fmt.Fprintf(os.Stderr, <span class="string">"error reading %s: %v\n"</span>, configFile, err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		config = &amp;cmdConfig</span><br><span class="line">		ss.UpdateConfig(config, config)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ss.UpdateConfig(config, &amp;cmdConfig)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> config.Method == <span class="string">""</span> &#123;</span><br><span class="line">		config.Method = <span class="string">"aes-256-cfb"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err = ss.CheckCipherMethod(config.Method); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintln(os.Stderr, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err = unifyPortPassword(config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> core &gt; <span class="number">0</span> &#123;</span><br><span class="line">		runtime.GOMAXPROCS(core)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> port, password := <span class="keyword">range</span> config.PortPassword &#123;</span><br><span class="line">		<span class="keyword">go</span> run(port, password)</span><br><span class="line">		<span class="keyword">if</span> udp &#123;</span><br><span class="line">			<span class="keyword">go</span> runUDP(port, password)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> managerAddr != <span class="string">""</span> &#123;</span><br><span class="line">		addr, err := net.ResolveUDPAddr(<span class="string">"udp"</span>, managerAddr)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintln(os.Stderr, <span class="string">"Can't resolve address: "</span>, err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		conn, err := net.ListenUDP(<span class="string">"udp"</span>, addr)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintln(os.Stderr, <span class="string">"Error listening:"</span>, err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(<span class="string">"manager listening udp addr %v ...\n"</span>, managerAddr)</span><br><span class="line">		<span class="keyword">defer</span> conn.Close()</span><br><span class="line">		<span class="keyword">go</span> managerDaemon(conn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	waitSignal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从以上代码中可以看到，server端main函数大体也分成三个部分，第一个部分负责处理一系列的配置文件解析，参数校验等。第二部分处理连接请求。第三部分为对server启动后进行的实时线上管理进行操作。</p>
<h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   flag.BoolVar(&amp;printVer, <span class="string">"version"</span>, <span class="literal">false</span>, <span class="string">"print version"</span>)</span><br><span class="line">flag.StringVar(&amp;configFile, <span class="string">"c"</span>, <span class="string">"config.json"</span>, <span class="string">"specify config file"</span>)</span><br><span class="line">flag.StringVar(&amp;cmdConfig.Password, <span class="string">"k"</span>, <span class="string">""</span>, <span class="string">"password"</span>)</span><br><span class="line">flag.IntVar(&amp;cmdConfig.ServerPort, <span class="string">"p"</span>, <span class="number">0</span>, <span class="string">"server port"</span>)</span><br><span class="line">flag.IntVar(&amp;cmdConfig.Timeout, <span class="string">"t"</span>, <span class="number">300</span>, <span class="string">"timeout in seconds"</span>)</span><br><span class="line">flag.StringVar(&amp;cmdConfig.Method, <span class="string">"m"</span>, <span class="string">""</span>, <span class="string">"encryption method, default: aes-256-cfb"</span>)</span><br><span class="line">flag.IntVar(&amp;core, <span class="string">"core"</span>, <span class="number">0</span>, <span class="string">"maximum number of CPU cores to use, default is determinied by Go runtime"</span>)</span><br><span class="line">flag.BoolVar((*<span class="keyword">bool</span>)(&amp;debug), <span class="string">"d"</span>, <span class="literal">false</span>, <span class="string">"print debug message"</span>)</span><br><span class="line">flag.BoolVar((*<span class="keyword">bool</span>)(&amp;sanitizeIps), <span class="string">"A"</span>, <span class="literal">false</span>, <span class="string">"anonymize client ip addresses in all output"</span>)</span><br><span class="line">flag.BoolVar(&amp;udp, <span class="string">"u"</span>, <span class="literal">false</span>, <span class="string">"UDP Relay"</span>)</span><br><span class="line">flag.StringVar(&amp;managerAddr, <span class="string">"manager-address"</span>, <span class="string">""</span>, <span class="string">"shadowsocks manager listening address"</span>)</span><br><span class="line">flag.Parse()</span><br></pre></td></tr></table></figure>
<p>这一部分个人感觉其实没什么，设置项目基本和local端保持一致。其中对于c pu的设置这里需要提一下，这是对于goroutine的设置，表示对于go逻辑处理器的分配。以及增加对于server运行时的管理设置。</p>
<h2 id="处理连接请求"><a href="#处理连接请求" class="headerlink" title="处理连接请求"></a>处理连接请求</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> port, password := <span class="keyword">range</span> config.PortPassword &#123;</span><br><span class="line">		<span class="keyword">go</span> run(port, password)</span><br><span class="line">		<span class="keyword">if</span> udp &#123;</span><br><span class="line">			<span class="keyword">go</span> runUDP(port, password)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>正如代码1-6行所示，根据配置的情况，server会处理多个端口的请求。由于支持了udp的socks代理加入udp判断，如果设置了udp转发，则进行udp的代理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func run(port, password string) &#123;</span><br><span class="line">	ln, err := net.Listen(&quot;tcp&quot;, &quot;:&quot;+port)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Printf(&quot;error listening port %v: %v\n&quot;, port, err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">	passwdManager.add(port, password, ln)</span><br><span class="line">	var cipher *ss.Cipher</span><br><span class="line">	log.Printf(&quot;server listening port %v ...\n&quot;, port)</span><br><span class="line">	for &#123;</span><br><span class="line">		conn, err := ln.Accept()</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			// listener maybe closed to update password</span><br><span class="line">			debug.Printf(&quot;accept error: %v\n&quot;, err)</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		// Creating cipher upon first connection.</span><br><span class="line">		if cipher == nil &#123;</span><br><span class="line">			log.Println(&quot;creating cipher for port:&quot;, port)</span><br><span class="line">			cipher, err = ss.NewCipher(config.Method, password)</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				log.Printf(&quot;Error generating cipher for port: %s %v\n&quot;, port, err)</span><br><span class="line">				conn.Close()</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		go handleConnection(ss.NewConn(conn, cipher.Copy()), port)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>run()函数主要负责监听本地接口等待连接，随后启动一个goroutine 来执行handleConnection()处理到来的连接请求。</p>
<h3 id="handleConnection"><a href="#handleConnection" class="headerlink" title="handleConnection"></a>handleConnection</h3><p>server对于请求的处理流程与local几乎相同，除了记录的日志信息不同。首先获取请求的目标地址，然后进行连接请求，最后创建两个PipeThenClose进行上行下行数据的传输，同时进行对数据的解密操作。整体流程如下：</p>
<div id="flowchart-0" class="flow-chart"></div>

<h2 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> managerAddr != <span class="string">""</span> &#123;</span><br><span class="line">		addr, err := net.ResolveUDPAddr(<span class="string">"udp"</span>, managerAddr)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintln(os.Stderr, <span class="string">"Can't resolve address: "</span>, err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		conn, err := net.ListenUDP(<span class="string">"udp"</span>, addr)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintln(os.Stderr, <span class="string">"Error listening:"</span>, err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(<span class="string">"manager listening udp addr %v ...\n"</span>, managerAddr)</span><br><span class="line">		<span class="keyword">defer</span> conn.Close()</span><br><span class="line">		<span class="keyword">go</span> managerDaemon(conn)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>对于shadowsocks的管理如果进行了设置，则会使用一个goroutine执行managerDaemon（）进行守护相关端口的监听，返回shadowsocks的运行情况。其中包括其流量连接情况：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, addr := <span class="keyword">range</span> reportconnSet &#123;</span><br><span class="line">					res := reportStat()</span><br><span class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(res) == <span class="number">0</span> &#123;</span><br><span class="line">						<span class="keyword">continue</span></span><br><span class="line">					&#125;</span><br><span class="line">					conn.WriteToUDP(res, addr)</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以使用的管理命令包括增加端口，删除端口，ping远程地址，停止ping等。相关代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> strings.HasPrefix(command, <span class="string">"add:"</span>):</span><br><span class="line">			res = handleAddPort(bytes.Trim(data[<span class="number">4</span>:], <span class="string">"\x00\r\n "</span>))</span><br><span class="line">		<span class="keyword">case</span> strings.HasPrefix(command, <span class="string">"remove:"</span>):</span><br><span class="line">			res = handleRemovePort(bytes.Trim(data[<span class="number">7</span>:], <span class="string">"\x00\r\n "</span>))</span><br><span class="line">		<span class="keyword">case</span> strings.HasPrefix(command, <span class="string">"ping"</span>):</span><br><span class="line">			conn.WriteToUDP(handlePing(), remote)</span><br><span class="line">			reportconnSet[remote.String()] = remote <span class="comment">// append the host into the report list</span></span><br><span class="line">		<span class="keyword">case</span> strings.HasPrefix(command, <span class="string">"ping-stop"</span>): <span class="comment">// add the stop ping command</span></span><br><span class="line">			conn.WriteToUDP(handlePing(), remote)</span><br><span class="line">			<span class="built_in">delete</span>(reportconnSet, remote.String())</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在main函数的最后，设置了一个waitSignal()用来等待Signal信号从而进行程序结束�前的收尾操作，当捕捉到该信号后进行updatePasswd等收尾操作。<br>至此整个shadowsocks的源码，大体上就分析完了。由于想基于一种全局的观点，所以一些极其细节的代码没有去阅读，重点其实还是在理解go语言在实际项目中的一些应用。<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始
op1=>operation: getRequest()获取请求目标地址
op2=>operation: net.Dial()请求目标地址建立连接
op3=>operation: ss.PipeThenClose()创建goroutine将数据发送到目的地
op4=>operation: ss.PipeThenClost()将将目的地的返回数据写入请求端
ed=>end: 结束
st->op1->op2->op3->op4->ed</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/01/go版本shadowsocks源码-终章/" data-id="cjyshtzqq0007kz2xd6l95acw" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">next &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">yiranblade&#39;s blog</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author"></h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>20</strong><br>文章</div></a>
      <a href="/categories"><div><strong>7</strong><br>分类</div></a>
      <a href="/tags"><div><strong>12</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/yiranblade" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="http://blog.yiranblade.cn/" target="_blank" title="ShanaMaid">
          ShanaMaid
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2018 - 2019 yiranblade&#39;s blog<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>

    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>

<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title class="menuItem">首页</a>
          
            <a href="/tags" title class="menuItem">标签</a>
          
            <a href="/categories" title class="menuItem">分类</a>
          
            <a href="/archives" title class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>







  </div>
</body>
</html>