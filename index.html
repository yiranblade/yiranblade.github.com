<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>yiranblade&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="yiranblade&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="yiranblade&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yiranblade&#39;s blog">
  
    <link rel="alternate" href="/atom.xml" title="yiranblade&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author"></h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>14</strong><br>文章</div></a>
      <a href="/categories"><div><strong>5</strong><br>分类</div></a>
      <a href="/tags"><div><strong>10</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-redis源码阅读-双端链表" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/27/redis源码阅读-双端链表/" class="article-date">
  <time class="post-time" datetime="2019-04-27T05:06:38.000Z" itemprop="datePublished">
    <span class="post-month">4月</span><br>
    <span class="post-day">27</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/27/redis源码阅读-双端链表/">redis源码阅读--双端链表</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis源码阅读/">redis源码阅读</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>em….链表是一种常用的数据结构。双端链表也是比较熟悉的了，redis的实现还是有必要研究一下的。</p>
<h2 id="redis中双端链表的应用"><a href="#redis中双端链表的应用" class="headerlink" title="redis中双端链表的应用"></a>redis中双端链表的应用</h2><h3 id="redis的列表类型"><a href="#redis的列表类型" class="headerlink" title="redis的列表类型"></a>redis的列表类型</h3><p>双端lian链表是redis列表类型的底层实现之一，当对列表类型的键进行操作–例如rpush、lpop或者llen等命令，程序在底层操作的<strong>可能</strong>就是双端链表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//这里之所以使用“可能”，是因为redis的列表其实使用两种数据结构作为底层实现：</span><br><span class="line">//1. 双端链表</span><br><span class="line">//2. 压缩列表</span><br><span class="line">//因为双端链表占用的内存比压缩列表要多，所以当创建新的列表键时，列表会优先考虑使用压缩列表作为底层实现，并且在有需要的时候，才会从压缩列表实现转换到双端列表的实现。</span><br></pre></td></tr></table></figure></p>
<h3 id="redis自身功能"><a href="#redis自身功能" class="headerlink" title="redis自身功能"></a>redis自身功能</h3><p>除了实现列表类型，双端链表还被redis内部模块所应用：</p>
<ul>
<li>事务模块使用双端列表依序保存输入的命令</li>
<li>服务器模块使用双端链表来保存多个客户端</li>
<li>订阅/发送模块使用双端列表来保存订阅模式的多个客户端</li>
<li>事件模块使用双端链表来保存时间事件</li>
</ul>
<h2 id="双端链表的实现"><a href="#双端链表的实现" class="headerlink" title="双端链表的实现"></a>双端链表的实现</h2><p>双端链表的实现由list和listNode这两个数据结构构成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line">    struct listNode *prev;</span><br><span class="line">    struct listNode *next;</span><br><span class="line">    void *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line">typedef struct list &#123;</span><br><span class="line">    listNode *head; //表头指针</span><br><span class="line">    listNode *tail; //表尾指针</span><br><span class="line">    void *(*dup)(void *ptr); //复制函数</span><br><span class="line">    void (*free)(void *ptr); //释放函数</span><br><span class="line">    int (*match)(void *ptr, void *key);//比对函数</span><br><span class="line">    unsigned long len; //节点数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的void表示双端列表对于节点保存的值的类型不做限制。<br>从数据结构的定义中可以看出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ list的遍历可以双向进行</span><br><span class="line">+ list对链表头和表尾进行插入的复杂度都为0(1)---从而可以做到高效实现lpush，rpop，rpoplpush等命令</span><br><span class="line">+ list带有保存节点数量的len属性，所以计算链表长度的复杂度仅为0（1），和之前sds一样读取长度不会成为性能瓶颈。</span><br></pre></td></tr></table></figure></p>
<p>操作双端链表的函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listEmpty</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span>;</span><br><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listJoin</span><span class="params">(<span class="built_in">list</span> *l, <span class="built_in">list</span> *o)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>redis还为双端链表实现了一个迭代器，这个迭代器可以从两个方向对双端列表进行迭代：</p>
<ul>
<li>沿着next指针前进，从表头到表尾</li>
<li>沿着节点的prev指针前进，从表尾向表头</li>
</ul>
<p>定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_HEAD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_TAIL 1</span></span><br></pre></td></tr></table></figure></p>
<p>其中，direction记录迭代从哪里开始，AL_START_HEA表示从表头开始，AL_START_TAIL 1表示从表尾开始。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>redis实现了自己的双端链表，其主要的作用用来作为redis列表类型的底层实现以及作为通用数据结构，被其他功能模块所使用。总体来说，这部分的代码不是很复杂，基本的实现都是当初学习c语言实现过的一些类似的东西，但是redis的设计者为其加上一点点额外的东西感觉就可以使得这些熟悉的东西变得灵活又作用强大，比如那个len字段的设计，看起来好像挺理所应当，但是在开始设计时，确实很难意识到这一点，往往看到别人的代码这样用才恍然大悟，所以学习的道路还很漫长。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/27/redis源码阅读-双端链表/" data-id="cjuz1npt7000psx2xvymm4zze" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-redis源码阅读-动态字符串" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/20/redis源码阅读-动态字符串/" class="article-date">
  <time class="post-time" datetime="2019-04-20T10:20:11.000Z" itemprop="datePublished">
    <span class="post-month">4月</span><br>
    <span class="post-day">20</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/20/redis源码阅读-动态字符串/">redis源码阅读--动态字符串</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis源码阅读/">redis源码阅读</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于char<em>类型的功能单一，抽象层次比较低，且无法高效支持一些Redis常用的操作（追加操作和长度计算操作），所以redis内部程序大多数时候会使用sds动态字符串类型而并不是char</em>表示。</p>
<h2 id="Redis中的字符串"><a href="#Redis中的字符串" class="headerlink" title="Redis中的字符串"></a>Redis中的字符串</h2><p>c语言中，字符串本质为一个使用\0结尾的char数组来表示。<br>但是这种形式无法支持长度计算和追加操作：</p>
<ul>
<li>每次计算字符串长度的复杂度为O(N)</li>
<li>对字符串进行N次追加，必定需要对字符串进行N次内存重分配</li>
</ul>
<p>但是在redis内部，字符串的追加长度和长度计算很常见，而APPEND和STRLEN更是这两种操作，在Redis命令中的直接映射，这两个简单的操作不应该成为性能的瓶颈。而且，Redis除了处理C字符串之外，还需要处理单纯的字节数组，以及服务器协议等，所以为了方便与安全，Redis的字符串表示应该是二进制安全的：程序不应该对字符串里面保存的数据做任何假设，即数据可以是以\0结尾的C字符串，也可以是单纯的字节数组，或者其他格式的数据。<br>基于此，Redis使用sds类型替换了C语言的默认字符串表示：sds既可以高效地追加和长度计算，同时也是二进制安全的。</p>
<h2 id="sds实现"><a href="#sds实现" class="headerlink" title="sds实现"></a>sds实现</h2><p>sds实现主要由两部分构成，第一部分是单纯的c中的char*:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br></pre></td></tr></table></figure></p>
<p>第二部分则为其涉及的具体sds数据类型，一共有5种：</p>
<table>
<thead>
<tr>
<th style="text-align:center">结构体类型</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sdshdr5</td>
<td style="text-align:center">保存5位长度字符串（不再使用）</td>
</tr>
<tr>
<td style="text-align:center">sdshdr8</td>
<td style="text-align:center">保存8位长度字符串</td>
</tr>
<tr>
<td style="text-align:center">sdshdr16</td>
<td style="text-align:center">保存16位长度字符串</td>
</tr>
<tr>
<td style="text-align:center">sdshdr32</td>
<td style="text-align:center">保存32位长度字符串</td>
</tr>
<tr>
<td style="text-align:center">sdshdr64</td>
<td style="text-align:center">保存64位长度字符串</td>
</tr>
</tbody>
</table>
<p>在这些结构中整体都可以提取为以下几个字段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    len ; </span><br><span class="line">    alloc ;</span><br><span class="line">    buf[] ;</span><br><span class="line">    flags ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这三个字段所表示的含义为：len代表buf的字符串长度，alloc代表整体的分配空间，buf为实际保存字符串数据的地方，flags保存了字符串的具体数据类型。<br>整体来看，我们就可以这样去理解整个sds的结构，类型sds是char*的别名，而结构sdshdr则保存了len、alloc、buf、flags四个属性。<br>使用这个结构来保存helloworld：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line">    len = 11;</span><br><span class="line">    alloc = 11;</span><br><span class="line">    buf = &#123;&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;,&apos;w&apos;,&apos;o&apos;,&apos;r&apos;,&apos;l&apos;,&apos;d&apos;,&apos;\0&apos;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由此我们就可以理解，redis是怎么优化读取len的速度了。直接读取sdslen属性就可以实现时间复杂度为θ(1) 的长度计算操作。另一点，通过对buf分配一些额外的空间，sdshdr 可以让执行追加操作所需的内存重分配次数大大减少。</p>
<h2 id="字符串追加操作的优化"><a href="#字符串追加操作的优化" class="headerlink" title="字符串追加操作的优化"></a>字符串追加操作的优化</h2><p>其实由前面的结构已经可以看出来了，这里实际上是redis在执行append操作时会进行一个内存预先分配的策略，如果内存足够就无需再次分配内存从而提高效率，减少重新分配内存的策略。这个套路好多编程语言软件在其动态数组或者说线性表的结构都会使用，java中的List,Go中的切片等等都有使用。<br>redis这里sds的分配策略实际是通过sdsMakeRoomFor这个函数来实现的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can't use realloc */</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, newlen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总体整理下该函数所作的操作为，首先获取剩余内存空间长度，如果剩余内存足够使用，则返回无需进行分配。需要新分配空间时计算新字符串所需的总长度，如果其长度小于SDS_MAX_PREALLOC那么为字符串分配2倍于所需长度的空间，否则就分配所需长度加上SDS_MAX_PREALLOC数量的空间。最后的一系列操作就是确认新的sds类型重新分配空间。<br><strong>在目前版本的 Redis 中， SDS_MAX_PREALLOC 的值为 1024 * 1024 ， 也就是说， 当大小小于 1MB 的字符串执行追加操作时， sdsMakeRoomFor 就为它们分配多于所需大小一倍的空间； 当字符串的大小大于 1MB ， 那么 sdsMakeRoomFor 就为它们额外多分配 1MB 的空间。</strong></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>对于redis来说，其内部字符串的实现采用sds来实现。我们从sds这一内部结构开始阅读redis的源代码，其数据类型结构部分与其余地方耦合度比较少，阅读起来还是比较容易的。<br>总结一下，sds大概的特点如下：</p>
<ul>
<li>Redis 的字符串表示为 sds ，而不是 C 字符串（以 \0 结尾的 char*）。</li>
<li>对比 C 字符串， sds 有以下特性：<ul>
<li>可以高效地执行长度计算（strlen）；</li>
<li>可以高效地执行追加操作（append）；</li>
<li>二进制安全；</li>
</ul>
</li>
<li>sds 会为追加操作进行优化：加快追加操作的速度，并降低内存分配的次数，代价是多占用了一些内存，而且这些内存不会被主动释放。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/20/redis源码阅读-动态字符串/" data-id="cjuz1npt3000lsx2x4pheyjmy" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-垃圾代码重构-《代码整洁之道》-读后感" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/14/垃圾代码重构-《代码整洁之道》-读后感/" class="article-date">
  <time class="post-time" datetime="2019-04-14T12:38:19.000Z" itemprop="datePublished">
    <span class="post-month">4月</span><br>
    <span class="post-day">14</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/14/垃圾代码重构-《代码整洁之道》-读后感/">垃圾代码重构-《代码整洁之道》-读后感</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/《代码整洁之道》读书笔记/">《代码整洁之道》读书笔记</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>根据作者的说法，该书大致上分为3个部分。第一部分主要介绍编写整洁代码的原则、模式和实践。第二部分结合实际的例子教导我们如何使用这些原则。第三部分则重点介绍得到的启示与灵感。目前的话我应该是读完了第一部分以及第二部分的一半左右，但是仅仅这部分的内容感觉就已经获益匪浅，在此记录一下。</p>
<h2 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h2><p>这一点，在我不长的编程生涯中，体会不可谓不深。截取一段自己在大学阶段项目里的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class LoginServiceImpl implements LoginService&#123;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private UserMapper userDao;</span><br><span class="line">	</span><br><span class="line">	@Autowired</span><br><span class="line">	private UserInfoMapper userInfoDao;</span><br><span class="line">	</span><br><span class="line">	public UserDto login(String username, String password) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		UserDto userDto=new UserDto();</span><br><span class="line">		User user=userDao.LoginService(username, password);</span><br><span class="line">		UserInfo userInfo=null;</span><br><span class="line">		if(user!=null)&#123;</span><br><span class="line">			userInfo=userInfoDao.selectByUserName(user.getUserName());</span><br><span class="line">			userDto.setUserName(user.getUserName());</span><br><span class="line">			userDto.setRole(user.getRole());</span><br><span class="line">			userDto.setDepartment(userInfo.getDepartment());</span><br><span class="line">			userDto.setEmail(userInfo.getEmail());</span><br><span class="line">			userDto.setName(userInfo.getName());</span><br><span class="line">			userDto.setCreateTime(userInfo.getCreateTime());</span><br><span class="line">			userDto.setUserId(userInfo.getUserId());</span><br><span class="line">			return userDto;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是自己当年上学时某个项目中的一个实现用户登录的逻辑，以现在的眼光或者说现在的经验来看，感觉命名糟糕的一踏糊涂。首先是类的命名，类的命名应该是一个名词，因为一个对象其方法才是具体的行为，在这里我用login作为命名一眼看过去就好像这整个类都在做登录这个动作，但实际上类代表的不是一个动作，这很不面向对象。其次是对象UserDto和userDao也意义不明，一眼看去根本不知道这个类到底是用来干嘛的。所以正如书中说的那样<strong>变量、函数或类的名称应该已经答复了所有的大问题。它应该告诉你，它为什么会存在，它做什么事情，应该怎么用</strong>。<br>还有一点避免使用编码，没有理由要求每位新人都在弄清楚要应付的代码之外，还要再搞懂另一种编码“语言”。感觉自己刚刚进公司就常常犯这种错误，比如xxxList，xxxSet之类的带有鲜明语言特色的东西，其实对阅读代码的人毫无帮助反而徒增了很多负担。在看看下面的一个排序代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;</span><br><span class="line">    int array[5] =&#123;4,2,1,4,5&#125;;</span><br><span class="line">    selectSort(array,5);</span><br><span class="line">    for(int i=0;i&lt;5;j++)&#123;</span><br><span class="line">        printf(&quot;%d&quot;,array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初学编程我们每个人应该都写过这样的排序代码，那在命名层面其有什么不妥呢？首先在代码开头定义的array变量就很意义不明，数组这一单词带有明显的编码色彩。其次是selectSort的函数命名，看起来是要排序，但是select是什么鬼，取出排序？对于函数命名应该言简意赅，意义明确，使用动词表达清其要做的事情，所以这里单纯用sort其实更好。最后是for循环的终止条件5，5这个数字在这段代码中表示什么？它在循环中表示什么的终止？显然这些问题仅仅靠单纯一个数字是没办法回答的。虽然这个程序现在很短小我们结合上下文阅读立马就可以反应过来，这个5是需要排序数组的大小，是待排数据的极值。但是如果程序变得很长很长呢，想象一下，你已经读了100来行代码了，现在又要求你回过头去结合上下文理解这个5的含义，任谁都会吐槽诅咒写的人吧。所以在编码中我们需要将这类意义不明的数字“5”换作一个具有意义的变量来表示其作用职责。<br>对于命名书中还涉及到了很多原则，在此就不做过多展开了，有兴趣可以去翻翻原作。由此看以看出，就单纯一项命名已经很考验编程功底了，所以千万不要胡乱命名给自己他人造成麻烦。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>短小，只做好一件事情。</strong>这是我对书中关于函数部分的最大印象。</p>
<ul>
<li>短小<br>即函数尽量要短，其实这个准则应该最大的好处就是读起来很很简单吧。按照作者的话说就是，每个函数都依序把你带到下一个函数。这就是函数应该达到的短小程度！！！即当我们面对一个长长的函数时，应该对其进行拆分将里面过长的内容拆分成一个个的小函数。这样不仅仅读的人赏心悦目，修改起来也很方便。</li>
<li>只做好一件事<br>个人感觉这条是最难以把握的，因为往往分不清这件事是不是应该这个函数做还是需要单独拆分。比如getStudentInfoById这个函数，根据名称来看应该是通过id获取学生信息，听起来貌似只需要从数据库中拿出学生信息并返回就可以了，但是学生信息还需要各种处理，比如需要有顺序的返回，或者说某些信息需要转换后返回，这些操作看起来与拿这个动作无关，但是确实是属于这个函数的附属品，不可能在函数名称中体现到这么多操作。其实，只要确保函数中的内容都在同一抽象级就好了，刚才说的各种对信息的处理其实可以拆分成使用formatXXX之类的函数完成，那么我们这个getStudentInfoById的函数就一共分为了两步，第一步从数据库拿出学生信息，第二部对其进行格式化。格式化与从数据库拿出这两个操作均在函数的同一抽象层，所以这两个操作都可以看作是为了完成拿出学生准确信息这一操作。</li>
</ul>
<p><strong>判断函数是否不止做了一件事，就是看是否能再拆岀一个函数，该函数不仅只是单纯地重新诠释其实现</strong>。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>这里我就记住一句话，<strong>唯一真正好的注释是你想办法不去写的注释</strong><br>尽量用代码去解释函数、类的行为，带有少量注释的整洁而有表达力的代码，要比大量注释的零碎而复杂的代码像样的多。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>代码格式很重要，感觉作者再书中不断强调这一点。尤其是一个项目团队大家都应当按照相同的格式去编写代码，这样有利于维护代码。从上往下的垂直格式总是必要的，还有最外层的文件的抽象概念由外到里依次变得细节。<br>运算符之间加空格区分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b + 2</span><br></pre></td></tr></table></figure></p>
<p>不同的区块也应该分割下，函数开头一般都是变量声明初始化之类的，所以就应该在初始化变量完成后，多一个换行之类的与接下来的代码区分，以此利于阅读。总之不管用什么风格，同一个团队应该保持一致，这样在后续开发中项目整体才比较容易维护，不同人不同的风格就会造成巨大的混乱，最终导致源代码不可读，不可维护。</p>
<h2 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h2><p><strong>当功能点需要常常添加新的结构时使用面向对象，需要常常添加新的方法行为使用面向过程</strong><br>所以说无论是面向对象或者是面向过程都是方法论，业务才是一切，没有永远适合的，只有当前适合的。<br><strong>一切都是对象只是一个传说</strong></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>这个仁者见仁智者见智，我只想说书中关于只使用异常的做法以前我可能会很认同，但最近在使用了go语言之后，对于没有异常处理机制的语言来说只使用异常就不再可能了，所以说看待问题还是不能太死板，没有什么是一成不变的，也没有绝对的真理。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类应该短小，且遵循单一权责原则，即类或者模块应有且只有一条加以修改的理由。<br>类应该只有少量实体变量，类中的每个方法都应该操作一个或多个这种变量，即类要保持内聚性。<br>如果说有很多方法并没有黏聚到类上，又或者为了保持函数和参数列表短小的策略，有时会导致为一组子集方法所用的实体变量数量增加。出现这种情况，就要拆分岀新的类了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/14/垃圾代码重构-《代码整洁之道》-读后感/" data-id="cjuz1nptv001osx2xhcxs1bn4" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/代码优化/">代码优化</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-go版本shadowsocks源码-终章" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/01/go版本shadowsocks源码-终章/" class="article-date">
  <time class="post-time" datetime="2019-04-01T09:00:52.000Z" itemprop="datePublished">
    <span class="post-month">4月</span><br>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/go版本shadowsocks源码-终章/">go版本shadowsocks源码-终章</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/shadowsocks源码/">shadowsocks源码</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本节我们来看一下shadowsocks-server端的源码。server端相比local端要简单不少，其所做的主要工作就是解码请求并返回结果。</p>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>照例我们从main函数开始分析其大致流程。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.SetOutput(os.Stdout)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> cmdConfig ss.Config</span><br><span class="line">	<span class="keyword">var</span> printVer <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> core <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	flag.BoolVar(&amp;printVer, <span class="string">"version"</span>, <span class="literal">false</span>, <span class="string">"print version"</span>)</span><br><span class="line">	flag.StringVar(&amp;configFile, <span class="string">"c"</span>, <span class="string">"config.json"</span>, <span class="string">"specify config file"</span>)</span><br><span class="line">	flag.StringVar(&amp;cmdConfig.Password, <span class="string">"k"</span>, <span class="string">""</span>, <span class="string">"password"</span>)</span><br><span class="line">	flag.IntVar(&amp;cmdConfig.ServerPort, <span class="string">"p"</span>, <span class="number">0</span>, <span class="string">"server port"</span>)</span><br><span class="line">	flag.IntVar(&amp;cmdConfig.Timeout, <span class="string">"t"</span>, <span class="number">300</span>, <span class="string">"timeout in seconds"</span>)</span><br><span class="line">	flag.StringVar(&amp;cmdConfig.Method, <span class="string">"m"</span>, <span class="string">""</span>, <span class="string">"encryption method, default: aes-256-cfb"</span>)</span><br><span class="line">	flag.IntVar(&amp;core, <span class="string">"core"</span>, <span class="number">0</span>, <span class="string">"maximum number of CPU cores to use, default is determinied by Go runtime"</span>)</span><br><span class="line">	flag.BoolVar((*<span class="keyword">bool</span>)(&amp;debug), <span class="string">"d"</span>, <span class="literal">false</span>, <span class="string">"print debug message"</span>)</span><br><span class="line">	flag.BoolVar((*<span class="keyword">bool</span>)(&amp;sanitizeIps), <span class="string">"A"</span>, <span class="literal">false</span>, <span class="string">"anonymize client ip addresses in all output"</span>)</span><br><span class="line">	flag.BoolVar(&amp;udp, <span class="string">"u"</span>, <span class="literal">false</span>, <span class="string">"UDP Relay"</span>)</span><br><span class="line">	flag.StringVar(&amp;managerAddr, <span class="string">"manager-address"</span>, <span class="string">""</span>, <span class="string">"shadowsocks manager listening address"</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> printVer &#123;</span><br><span class="line">		ss.PrintVersion()</span><br><span class="line">		os.Exit(<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ss.SetDebug(debug)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	config, err = ss.ParseConfig(configFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !os.IsNotExist(err) &#123;</span><br><span class="line">			fmt.Fprintf(os.Stderr, <span class="string">"error reading %s: %v\n"</span>, configFile, err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		config = &amp;cmdConfig</span><br><span class="line">		ss.UpdateConfig(config, config)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ss.UpdateConfig(config, &amp;cmdConfig)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> config.Method == <span class="string">""</span> &#123;</span><br><span class="line">		config.Method = <span class="string">"aes-256-cfb"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err = ss.CheckCipherMethod(config.Method); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintln(os.Stderr, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err = unifyPortPassword(config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> core &gt; <span class="number">0</span> &#123;</span><br><span class="line">		runtime.GOMAXPROCS(core)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> port, password := <span class="keyword">range</span> config.PortPassword &#123;</span><br><span class="line">		<span class="keyword">go</span> run(port, password)</span><br><span class="line">		<span class="keyword">if</span> udp &#123;</span><br><span class="line">			<span class="keyword">go</span> runUDP(port, password)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> managerAddr != <span class="string">""</span> &#123;</span><br><span class="line">		addr, err := net.ResolveUDPAddr(<span class="string">"udp"</span>, managerAddr)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintln(os.Stderr, <span class="string">"Can't resolve address: "</span>, err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		conn, err := net.ListenUDP(<span class="string">"udp"</span>, addr)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintln(os.Stderr, <span class="string">"Error listening:"</span>, err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(<span class="string">"manager listening udp addr %v ...\n"</span>, managerAddr)</span><br><span class="line">		<span class="keyword">defer</span> conn.Close()</span><br><span class="line">		<span class="keyword">go</span> managerDaemon(conn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	waitSignal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从以上代码中可以看到，server端main函数大体也分成三个部分，第一个部分负责处理一系列的配置文件解析，参数校验等。第二部分处理连接请求。第三部分为对server启动后进行的实时线上管理进行操作。</p>
<h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   flag.BoolVar(&amp;printVer, <span class="string">"version"</span>, <span class="literal">false</span>, <span class="string">"print version"</span>)</span><br><span class="line">flag.StringVar(&amp;configFile, <span class="string">"c"</span>, <span class="string">"config.json"</span>, <span class="string">"specify config file"</span>)</span><br><span class="line">flag.StringVar(&amp;cmdConfig.Password, <span class="string">"k"</span>, <span class="string">""</span>, <span class="string">"password"</span>)</span><br><span class="line">flag.IntVar(&amp;cmdConfig.ServerPort, <span class="string">"p"</span>, <span class="number">0</span>, <span class="string">"server port"</span>)</span><br><span class="line">flag.IntVar(&amp;cmdConfig.Timeout, <span class="string">"t"</span>, <span class="number">300</span>, <span class="string">"timeout in seconds"</span>)</span><br><span class="line">flag.StringVar(&amp;cmdConfig.Method, <span class="string">"m"</span>, <span class="string">""</span>, <span class="string">"encryption method, default: aes-256-cfb"</span>)</span><br><span class="line">flag.IntVar(&amp;core, <span class="string">"core"</span>, <span class="number">0</span>, <span class="string">"maximum number of CPU cores to use, default is determinied by Go runtime"</span>)</span><br><span class="line">flag.BoolVar((*<span class="keyword">bool</span>)(&amp;debug), <span class="string">"d"</span>, <span class="literal">false</span>, <span class="string">"print debug message"</span>)</span><br><span class="line">flag.BoolVar((*<span class="keyword">bool</span>)(&amp;sanitizeIps), <span class="string">"A"</span>, <span class="literal">false</span>, <span class="string">"anonymize client ip addresses in all output"</span>)</span><br><span class="line">flag.BoolVar(&amp;udp, <span class="string">"u"</span>, <span class="literal">false</span>, <span class="string">"UDP Relay"</span>)</span><br><span class="line">flag.StringVar(&amp;managerAddr, <span class="string">"manager-address"</span>, <span class="string">""</span>, <span class="string">"shadowsocks manager listening address"</span>)</span><br><span class="line">flag.Parse()</span><br></pre></td></tr></table></figure>
<p>这一部分个人感觉其实没什么，设置项目基本和local端保持一致。其中对于c pu的设置这里需要提一下，这是对于goroutine的设置，表示对于go逻辑处理器的分配。以及增加对于server运行时的管理设置。</p>
<h2 id="处理连接请求"><a href="#处理连接请求" class="headerlink" title="处理连接请求"></a>处理连接请求</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> port, password := <span class="keyword">range</span> config.PortPassword &#123;</span><br><span class="line">		<span class="keyword">go</span> run(port, password)</span><br><span class="line">		<span class="keyword">if</span> udp &#123;</span><br><span class="line">			<span class="keyword">go</span> runUDP(port, password)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>正如代码1-6行所示，根据配置的情况，server会处理多个端口的请求。由于支持了udp的socks代理加入udp判断，如果设置了udp转发，则进行udp的代理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func run(port, password string) &#123;</span><br><span class="line">	ln, err := net.Listen(&quot;tcp&quot;, &quot;:&quot;+port)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Printf(&quot;error listening port %v: %v\n&quot;, port, err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">	passwdManager.add(port, password, ln)</span><br><span class="line">	var cipher *ss.Cipher</span><br><span class="line">	log.Printf(&quot;server listening port %v ...\n&quot;, port)</span><br><span class="line">	for &#123;</span><br><span class="line">		conn, err := ln.Accept()</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			// listener maybe closed to update password</span><br><span class="line">			debug.Printf(&quot;accept error: %v\n&quot;, err)</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		// Creating cipher upon first connection.</span><br><span class="line">		if cipher == nil &#123;</span><br><span class="line">			log.Println(&quot;creating cipher for port:&quot;, port)</span><br><span class="line">			cipher, err = ss.NewCipher(config.Method, password)</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				log.Printf(&quot;Error generating cipher for port: %s %v\n&quot;, port, err)</span><br><span class="line">				conn.Close()</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		go handleConnection(ss.NewConn(conn, cipher.Copy()), port)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>run()函数主要负责监听本地接口等待连接，随后启动一个goroutine 来执行handleConnection()处理到来的连接请求。</p>
<h3 id="handleConnection"><a href="#handleConnection" class="headerlink" title="handleConnection"></a>handleConnection</h3><p>server对于请求的处理流程与local几乎相同，除了记录的日志信息不同。首先获取请求的目标地址，然后进行连接请求，最后创建两个PipeThenClose进行上行下行数据的传输，同时进行对数据的解密操作。整体流程如下：</p>
<div id="flowchart-0" class="flow-chart"></div>

<h2 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> managerAddr != <span class="string">""</span> &#123;</span><br><span class="line">		addr, err := net.ResolveUDPAddr(<span class="string">"udp"</span>, managerAddr)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintln(os.Stderr, <span class="string">"Can't resolve address: "</span>, err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		conn, err := net.ListenUDP(<span class="string">"udp"</span>, addr)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintln(os.Stderr, <span class="string">"Error listening:"</span>, err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(<span class="string">"manager listening udp addr %v ...\n"</span>, managerAddr)</span><br><span class="line">		<span class="keyword">defer</span> conn.Close()</span><br><span class="line">		<span class="keyword">go</span> managerDaemon(conn)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>对于shadowsocks的管理如果进行了设置，则会使用一个goroutine执行managerDaemon（）进行守护相关端口的监听，返回shadowsocks的运行情况。其中包括其流量连接情况：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, addr := <span class="keyword">range</span> reportconnSet &#123;</span><br><span class="line">					res := reportStat()</span><br><span class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(res) == <span class="number">0</span> &#123;</span><br><span class="line">						<span class="keyword">continue</span></span><br><span class="line">					&#125;</span><br><span class="line">					conn.WriteToUDP(res, addr)</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以使用的管理命令包括增加端口，删除端口，ping远程地址，停止ping等。相关代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> strings.HasPrefix(command, <span class="string">"add:"</span>):</span><br><span class="line">			res = handleAddPort(bytes.Trim(data[<span class="number">4</span>:], <span class="string">"\x00\r\n "</span>))</span><br><span class="line">		<span class="keyword">case</span> strings.HasPrefix(command, <span class="string">"remove:"</span>):</span><br><span class="line">			res = handleRemovePort(bytes.Trim(data[<span class="number">7</span>:], <span class="string">"\x00\r\n "</span>))</span><br><span class="line">		<span class="keyword">case</span> strings.HasPrefix(command, <span class="string">"ping"</span>):</span><br><span class="line">			conn.WriteToUDP(handlePing(), remote)</span><br><span class="line">			reportconnSet[remote.String()] = remote <span class="comment">// append the host into the report list</span></span><br><span class="line">		<span class="keyword">case</span> strings.HasPrefix(command, <span class="string">"ping-stop"</span>): <span class="comment">// add the stop ping command</span></span><br><span class="line">			conn.WriteToUDP(handlePing(), remote)</span><br><span class="line">			<span class="built_in">delete</span>(reportconnSet, remote.String())</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在main函数的最后，设置了一个waitSignal()用来等待Signal信号从而进行程序结束�前的收尾操作，当捕捉到该信号后进行updatePasswd等收尾操作。<br>至此整个shadowsocks的源码，大体上就分析完了。由于想基于一种全局的观点，所以一些极其细节的代码没有去阅读，重点其实还是在理解go语言在实际项目中的一些应用。<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始
op1=>operation: getRequest()获取请求目标地址
op2=>operation: net.Dial()请求目标地址建立连接
op3=>operation: ss.PipeThenClose()创建goroutine将数据发送到目的地
op4=>operation: ss.PipeThenClost()将将目的地的返回数据写入请求端
ed=>end: 结束
st->op1->op2->op3->op4->ed</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/01/go版本shadowsocks源码-终章/" data-id="cjuz1npsu0007sx2x8w35t7yp" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-go版本shadowsocks源码-二" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/28/go版本shadowsocks源码-二/" class="article-date">
  <time class="post-time" datetime="2019-03-28T12:29:39.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br>
    <span class="post-day">28</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/28/go版本shadowsocks源码-二/">go版本shadowsocks源码(二)</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/shadowsocks源码/">shadowsocks源码</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本节来分析下，在上次开启本地服务等待连接后，handleConnection()函数是怎样处理拿到的请求的。</p>
<h2 id="socks5协议客户端连接要求"><a href="#socks5协议客户端连接要求" class="headerlink" title="socks5协议客户端连接要求"></a>socks5协议客户端连接要求</h2><p>在看具体的代码之前，我们首先来看看官方标准中是如何规定本地与客户端之间的交互的。<br>协议规定当客户端连到服务器后，然后就发送请求来协商版本和认证方法：<br>|VER|NMETHODS|METHODS|<br>:-:|:-:<br>|1|1|1 to 255|<br>其中ver表示协议版本（固定长度为一个字节），nmethods表示第三个字段的长度（即有几种认证方法），methods表示客户端支持的验证方式，长度1-255字节。<br>支持的验证方式官方制定了以下几种：</p>
<ul>
<li>0x00:NO AUTHENTICATION REQUIRED（不需要验证）</li>
<li>0x01:GSSAPI (通用安全服务应用程序接口)</li>
<li>0x02:USERNAME/PASSWD(用户名密码)</li>
<li>0x03:IANA ASSIGNED(至 0x’7F’ IANA 分配)</li>
<li>0x80:RESERVED FOR PRIVATE METHODS(至 0x’FE’ 私人方法保留)</li>
<li>0xff:NO ACCEPTABLE METHODS(没有可接受的方法)</li>
</ul>
<p>当服务端收到客户端的验证信息后，就要回应客户端提供哪种验证方式的信息。回应格式如下：<br>|VER|METHOD|<br>:-:|:-:<br>|1|1|</p>
<h2 id="handleConnect函数"><a href="#handleConnect函数" class="headerlink" title="handleConnect函数"></a>handleConnect函数</h2><p>现在我们来看hendleConnect函数是如何处理�连接的：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> debug &#123;</span><br><span class="line">		debug.Printf(<span class="string">"socks connect from %s\n"</span>, conn.RemoteAddr().String())</span><br><span class="line">	&#125;</span><br><span class="line">	closed := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !closed &#123;</span><br><span class="line">			conn.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> err error = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> err = handShake(conn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"socks handshake:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	rawaddr, addr, err := getRequest(conn)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"error getting request:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Sending connection established message immediately to client.</span></span><br><span class="line">	<span class="comment">// This some round trip time for creating socks connection with the client.</span></span><br><span class="line">	<span class="comment">// But if connection failed, the client will get connection reset error.</span></span><br><span class="line">	_, err = conn.Write([]<span class="keyword">byte</span>&#123;<span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x43</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		debug.Println(<span class="string">"send connection confirmation:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	remote, err := createServerConn(rawaddr, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(servers.srvCipher) &gt; <span class="number">1</span> &#123;</span><br><span class="line">			log.Println(<span class="string">"Failed connect to all available shadowsocks server"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !closed &#123;</span><br><span class="line">			remote.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> ss.PipeThenClose(conn, remote, <span class="literal">nil</span>)</span><br><span class="line">	ss.PipeThenClose(remote, conn, <span class="literal">nil</span>)</span><br><span class="line">	closed = <span class="literal">true</span></span><br><span class="line">	debug.Println(<span class="string">"closed connection to"</span>, addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先我们可以看到在代码13行-16行，对连接进行请求的协商，也就是第一部分介绍的交互协商认证的流程。<br><strong>handShake代码如下</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func handShake(conn net.Conn) (err error) &#123;</span><br><span class="line">	const (</span><br><span class="line">		idVer     = 0</span><br><span class="line">		idNmethod = 1</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	buf := make([]byte, 258)</span><br><span class="line"></span><br><span class="line">	var n int</span><br><span class="line">	ss.SetReadTimeout(conn)</span><br><span class="line">	if n, err = io.ReadAtLeast(conn, buf, idNmethod+1); err != nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	if buf[idVer] != socksVer5 &#123;</span><br><span class="line">		return errVer</span><br><span class="line">	&#125;</span><br><span class="line">	nmethod := int(buf[idNmethod])</span><br><span class="line">	msgLen := nmethod + 2</span><br><span class="line">	if n == msgLen &#123; </span><br><span class="line">	&#125; else if n &lt; msgLen &#123; </span><br><span class="line">		if _, err = io.ReadFull(conn, buf[n:msgLen]); err != nil &#123;</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123; </span><br><span class="line">		return errAuthExtraData</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = conn.Write([]byte&#123;socksVer5, 0&#125;)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码11行读取了本地客户端发来的版本信息以及认证方法信息，如果协议版本不是socks5则立马返回。由于socks规定的字段ver与nmethods都是两个字节所以最后一个字段加上2个字节就是需要读取的信息总长度，最后第27行代码返回给客户端协议版本信息与选择的方法（此处不需要验证，所以传递0）。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rawaddr, addr, err := getRequest(conn)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Println(&quot;error getting request:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>然后让我们把视角在回到handleConnection函数，在完成handshake的认证后客户端会向local发送一个带有目的地址和端口的请求包，由request函数完成获取操作。以下是发送的包内容：<br>|VER|CMD|RSV|ATYP|DST.ADDR|DST.PORT|<br>:-:|:-:|:-:|<br>|1|1|0x00|1|Variable|2|</p>
<ul>
<li>VER:socks的版本</li>
<li>CMD:代表客户端请求的类型，值长度1个字节，有三种类型：<ul>
<li>Connect:0x01</li>
<li>Bind:0x02</li>
<li>UDP:0x03</li>
</ul>
</li>
<li>RSV:保留字段，默认0x00，长度1个字节</li>
<li>ATYP:代表请求的远程服务器地址类型，长度1个字节，三种类型：<ul>
<li>IPV4:0X01</li>
<li>IPV6:0X04</li>
<li>DOMAINNAME:0x03</li>
</ul>
</li>
<li>DST.ADDR:代表远程服务器的地址，根据ATYP进行解析，值长度不定</li>
<li>DST.PORT:代表远程服务器的端口，值长度2个字节</li>
</ul>
<p>当loca接收到该信息，接下来应当向客户端返回一个结果，在代码中默认返回了success。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, err = conn.Write([]byte&#123;0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x43&#125;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		debug.Println(&quot;send connection confirmation:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>当这些步骤完成后，接下来local端和server端建立连接。然后local负责把client的数据包加密后发送给ss-server。把收到的server数据包在发回给client。完成这些操作的函数就是PipeThenClose。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func PipeThenClose(src, dst net.Conn, addTraffic func(int)) &#123;</span><br><span class="line">	defer dst.Close()</span><br><span class="line">	buf := leakyBuf.Get()</span><br><span class="line">	defer leakyBuf.Put(buf)</span><br><span class="line">	for &#123;</span><br><span class="line">		SetReadTimeout(src)</span><br><span class="line">		n, err := src.Read(buf)</span><br><span class="line">		if addTraffic != nil &#123;</span><br><span class="line">			addTraffic(n)</span><br><span class="line">		&#125;</span><br><span class="line">		// read may return EOF with n &gt; 0</span><br><span class="line">		// should always process n &gt; 0 bytes before handling error</span><br><span class="line">		if n &gt; 0 &#123;</span><br><span class="line">			// Note: avoid overwrite err returned by Read.</span><br><span class="line">			if _, err := dst.Write(buf[0:n]); err != nil &#123;</span><br><span class="line">				Debug.Println(&quot;write:&quot;, err)</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			// Always &quot;use of closed network connection&quot;, but no easy way to</span><br><span class="line">			// identify this specific error. So just leave the error along for now.</span><br><span class="line">			// More info here: https://code.google.com/p/go/issues/detail?id=4373</span><br><span class="line">			/*</span><br><span class="line">				if bool(Debug) &amp;&amp; err != io.EOF &#123;</span><br><span class="line">					Debug.Println(&quot;read:&quot;, err)</span><br><span class="line">				&#125;</span><br><span class="line">			*/</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在PipeThenClose代码中，其申请一块缓冲区然后不停的从src中读取数据，将数据转发到dst中。当然，读取的时候需要对数据进行解密，写的时候需要加密。解密加密操作分别由项目中的Conn负责，其重写了read与write函数，在read时会根据加密方法对数据进行解密。write时则会进行加密。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go ss.PipeThenClose(conn, remote, nil)</span><br><span class="line">	ss.PipeThenClose(remote, conn, nil)</span><br><span class="line">	closed = true</span><br><span class="line">	debug.Println(&quot;closed connection to&quot;, addr)</span><br></pre></td></tr></table></figure></p>
<p>在handleConnection代码的最后，其使用两个PipeThenClose，新开启的goroutine和本身的goroutine病发的从本地到远程、远程到本地的上下行进行数据传输。</p>
<p>综上，handleConnection函数整体流程如下：</p>
<div id="flowchart-0" class="flow-chart"></div>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>local端的代码到此就算结束了，由于是按照整体流程进行分析，有些过于细节的地方几句就略过去了，重点还是在学习整体的流程以及socks协议的使用。server端的思路其实和local端比较类似，除了没有local中握手（handShake）的步骤。整体看来这个还是不太复杂的，整体代码也就2000行左右。</p>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">stat=>start: 开始
op1=>operation: handShake认证协商操作
op2=>operation: getRequest获取目标地址
op3=>operation: createServerConn创建与远程服务端的连接
op4=>operation: 利用PipeThenClose将数据传输至服务端(并发操作)
op5=>operation: 利用PipeThenClose从远程服务端接收数据
ed=>end: 结束

stat->op1->op2->op3->op4->op5->ed</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/28/go版本shadowsocks源码-二/" data-id="cjuz1npst0006sx2xt9g4q93e" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-go语言读书笔记-aciton系列（并发）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/27/go语言读书笔记-aciton系列（并发）/" class="article-date">
  <time class="post-time" datetime="2019-03-27T09:43:48.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br>
    <span class="post-day">27</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/27/go语言读书笔记-aciton系列（并发）/">go语言读书笔记-aciton系列（并发）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/《go语言实战》读书笔记/">《go语言实战》读书笔记</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>终于到并发了，阅读本章总有种go对并发的处理简洁高效的感觉。action系列举的实战例子也很通俗易懂，感觉运用一些实际的项目实践应该理解会更加深刻。</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>操作系统会在物理处理器上调度线程来运行程序，而Go语言运行时会在逻辑处理器上调用goroutine来运行。每个逻辑处理器都分别绑定到单个操作系统线程。<br>em。。goroutine可以理解为携程，就像这样。<br><img src="http://static.zybuluo.com/yiranblade/3efzy0kylh5qa5gt84q8e2dn/image_1d6fdftt11ti71crn1qn2c791uls9.png" alt="image_1d6fdftt11ti71crn1qn2c791uls9.png-230.1kB"><br>携程运行于线程之上，比线程更加轻量级。goroutine运行于逻辑处理器，而逻辑处理器就对应一个操作系统线程，其可以并发调度无数个groutine。</p>
<p>goroutine也可以并行运行，只要使用超过一个的逻辑处理器。但是只要底层硬件层面只有一个处理器，即使创建了多个逻辑处理器也依然是并发运行。<br><img src="http://static.zybuluo.com/yiranblade/2b8csvfn7li8kccrb5ftzl4p/image_1d6felqb512qn1r251k38110tchqm.png" alt="image_1d6felqb512qn1r251k38110tchqm.png-183.9kB"><br>并发并行的区别正如书上的图所示。<br>通过设置参数可以给每个可用的物理处理器分配一个逻辑处理器，从而达到并行的目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &quot;runtime&quot;</span><br><span class="line"></span><br><span class="line">runtime.GOMAXPROCS(runtime.NumCpu())</span><br></pre></td></tr></table></figure></p>
<h2 id="同步goroutine"><a href="#同步goroutine" class="headerlink" title="同步goroutine"></a>同步goroutine</h2><p>在写并发代码时，往往都会遇到竞争状态的问题。这就需要采用一些同步手段来得到正确的结果。go语言提供了锁的机制来同步。</p>
<h3 id="原子函数"><a href="#原子函数" class="headerlink" title="原子函数"></a>原子函数</h3><p>go sync包提供了一些常用的操作的原子函数。当使用这些函数来读，写时，其都会自动根据所引用的变量做同步处理。已addint64函数示例:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    counter <span class="keyword">int64</span></span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> incCounter(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> incCounter(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    wg.Wait()</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">"Final Counter:"</span>,counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> count :=<span class="number">0</span>; count&lt;<span class="number">2</span>;count++&#123;</span><br><span class="line">        atomic.AddInt64(&amp;counter,<span class="number">1</span>)</span><br><span class="line">        runtime.Goshed()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序一开始创建两个goroutine形成对counter变量的竞争条件。而AddInt64函数则强制同一时刻 只能有一个goroutine运行并完成这个加法操作。当goroutine试图取d去调用任何原子函数时，这些goroutine都会自动根据所引用的变量做同步处理。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁就和我们通常使用的许多语言中的锁机制一样，在代码中创建一个临界区，保证同一时间只有一个goroutine可以执行这个临界区的代码。<br>对刚刚的程序使用锁机制同步就是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;runtime&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;sync/atomic&quot;</span><br><span class="line">)</span><br><span class="line">var (</span><br><span class="line">    counter int64</span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    wg.Add(2)</span><br><span class="line">    </span><br><span class="line">    go incCounter(1)</span><br><span class="line">    go incCounter(2)</span><br><span class="line">    </span><br><span class="line">    wg.Wait()</span><br><span class="line">    </span><br><span class="line">    fmt.Println(&quot;Final Counter:&quot;,counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func incCounter(id int)&#123;</span><br><span class="line">    defer wg.Done()</span><br><span class="line">    for count :=0; count&lt;2;count++&#123;</span><br><span class="line">        mutex.Lock()</span><br><span class="line">        &#123;</span><br><span class="line">            value := counter</span><br><span class="line">            runtime.Gosched()</span><br><span class="line">            value++</span><br><span class="line">            counter = value</span><br><span class="line">        &#125;</span><br><span class="line">        mutex.UnLock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同一时刻只能有一个goroutine可以进入临界区。之后，直到调用Unlock()函数之后，其他goroutine才能进入临界区。</p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>go语言中提供了通道，通过发送和接收需要共享的资源，在goroutine之间做同步。<br><strong>通道分为无缓冲通道和有缓冲的通道。无缓冲的通道是指在接收前没有能力保存任何值的通道。这种类型的通道要求发送goroutine和接收goroutine同时准备好，才能完成发送和接收操作。如果两个goroutine没有同时准备好，通道会导致先执行发送或接收操作的goroutine阻塞等待。这种对通道进行发送和接收的交互行为本身就是同步的。</strong></p>
<p><strong>有缓冲的通道是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求goroutine之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值的时，发送动作才会阻塞。这导致有缓冲的通道和无缓冲的通道之间有一个很大的不同：无缓冲的通道保证进行发送和接收的goroutine会在同一时间进行数据交换了；有缓冲的通道没有这种保证。</strong></p>
<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>至此，对于goaction系列中对于go语言语法特性的部分，就算是阅读完毕了。书中举了很多这些语法的实际应用场景例子，但是实际掌握还是需要自己动手写以及多看看别人项目的源代码，个人感觉这样才能得到最快的提升。所以接下来的action章节读书笔记，就主要记录书中实际的demo吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/27/go语言读书笔记-aciton系列（并发）/" data-id="cjuz1npsv0008sx2xiue32y0w" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-go版本shadowsocks源码(一)" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/19/go版本shadowsocks源码(一)/" class="article-date">
  <time class="post-time" datetime="2019-03-19T12:01:52.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br>
    <span class="post-day">19</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/19/go版本shadowsocks源码(一)/">go版本shadowsocks源码(一)</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/shadowsocks源码/">shadowsocks源码</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="shadowsocks简介"><a href="#shadowsocks简介" class="headerlink" title="shadowsocks简介"></a>shadowsocks简介</h2><p>Shadowsocks（简称SS）是一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种开发包。当前包使用Python、C、C++、C#、Go语言等编程语言开发，大部分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。</p>
<p>而socks5协议则是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。根据OSI七层模型来划分，SOCKS属于会话层协议，位于表示层与传输层之间。</p>
<p>当防火墙后的客户端要访问外部的服务器时，就跟socks代理服务器连接。该协议设计之初是为了让有权限的用户可以穿过过防火墙的限制，使得高权限用户可以访问外部资源。经过10余年的时间，大量的网络应用程序都支持socks5代理。</p>
<hr>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>首先我们来看下客户端的代码。</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>go语言和大多数语言一样都是从main函数开始的，在源码阅读的过程我们也从main函数开始逐步往下分析。<br>mian函数整体我认为可以分为三个部分，第一部分读取相关的配置信息，第二部分处理服务器配置信息，第三部分启动客户端，监听本地端口。</p>
<h4 id="读取客户端启动的配置信息"><a href="#读取客户端启动的配置信息" class="headerlink" title="读取客户端启动的配置信息"></a>读取客户端启动的配置信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">                       ......</span><br><span class="line">   flag.BoolVar(&amp;printVer, &quot;version&quot;, false, &quot;print version&quot;)</span><br><span class="line">flag.StringVar(&amp;configFile, &quot;c&quot;, &quot;config.json&quot;, &quot;specify config file&quot;)</span><br><span class="line">flag.StringVar(&amp;cmdServer, &quot;s&quot;, &quot;&quot;, &quot;server address&quot;)</span><br><span class="line">flag.StringVar(&amp;cmdConfig.LocalAddress, &quot;b&quot;, &quot;&quot;, &quot;local address, listen only to this address if specified&quot;)</span><br><span class="line">flag.StringVar(&amp;cmdConfig.Password, &quot;k&quot;, &quot;&quot;, &quot;password&quot;)</span><br><span class="line">flag.IntVar(&amp;cmdConfig.ServerPort, &quot;p&quot;, 0, &quot;server port&quot;)</span><br><span class="line">flag.IntVar(&amp;cmdConfig.Timeout, &quot;t&quot;, 300, &quot;timeout in seconds&quot;)</span><br><span class="line">flag.IntVar(&amp;cmdConfig.LocalPort, &quot;l&quot;, 0, &quot;local socks5 proxy port&quot;)</span><br><span class="line">flag.StringVar(&amp;cmdConfig.Method, &quot;m&quot;, &quot;&quot;, &quot;encryption method, default: aes-256-cfb&quot;)</span><br><span class="line">flag.BoolVar((*bool)(&amp;debug), &quot;d&quot;, false, &quot;print debug message&quot;)</span><br><span class="line">flag.StringVar(&amp;cmdURI, &quot;u&quot;, &quot;&quot;, &quot;shadowsocks URI&quot;)</span><br><span class="line">                    ......</span><br><span class="line">                    </span><br><span class="line">config, err := ss.ParseConfig(configFile)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">	config = &amp;cmdConfig</span><br><span class="line">	if !os.IsNotExist(err) &#123;</span><br><span class="line">		fmt.Fprintf(os.Stderr, &quot;error reading %s: %v\n&quot;, configFile, err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	ss.UpdateConfig(config, &amp;cmdConfig)</span><br><span class="line">&#125;</span><br><span class="line">if config.Method == &quot;&quot; &#123;</span><br><span class="line">	config.Method = &quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中我们可以看到，除了从命令行读取配置信息外，还可以指定json文件读取配置信息。ss的配置信息包括这样几个部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   Server       interface&#123;&#125; `json:&quot;server&quot;`</span><br><span class="line">ServerPort   int         `json:&quot;server_port&quot;`</span><br><span class="line">LocalPort    int         `json:&quot;local_port&quot;`</span><br><span class="line">LocalAddress string      `json:&quot;local_address&quot;`</span><br><span class="line">Password     string      `json:&quot;password&quot;`</span><br><span class="line">Method       string      `json:&quot;method&quot;` // encryption method</span><br><span class="line"></span><br><span class="line">// following options are only used by server</span><br><span class="line">PortPassword map[string]string `json:&quot;port_password&quot;`</span><br><span class="line">Timeout      int               `json:&quot;timeout&quot;`</span><br><span class="line"></span><br><span class="line">// following options are only used by client</span><br><span class="line"></span><br><span class="line">// The order of servers in the client config is significant, so use array</span><br><span class="line">// instead of map to preserve the order.</span><br><span class="line">ServerPassword [][]string `json:&quot;server_password&quot;`</span><br></pre></td></tr></table></figure></p>
<p>从上往下分为客户端配置和服务端配置，其中客户端配置包括远程服务器ip，服务器端口，本地端口，本地地址访问密码，加密方法，服务端配置包括设定端口密码等。<br>对于go语言来说从命令行读取相应的参数感觉是一件十分方便的事情<br>，只要调用flag包相关函数即可读取并规定想要的格式参数。</p>
<h4 id="处理服务器配置信息"><a href="#处理服务器配置信息" class="headerlink" title="处理服务器配置信息"></a>处理服务器配置信息</h4><p>服务器配置信息这里使用了两个结构体来存储读取的配置信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type ServerCipher struct &#123;</span><br><span class="line">	server string</span><br><span class="line">	cipher *ss.Cipher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var servers struct &#123;</span><br><span class="line">	srvCipher []*ServerCipher</span><br><span class="line">	failCnt   []int // failed connection count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实阅读这里我是不太理解，为什么要在用一个匿名结构体将server密码信息包起来的，而且servercipher这个名字也怪怪的，因为里面不仅仅包含server的密码信息呀。可能是因为单独记录shi失败次数有利于后续扩展？这个后面想到在补吧。使用数组就很显然了，为了支持配置多个服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">func parseServerConfig(config *ss.Config) &#123;</span><br><span class="line">	hasPort := func(s string) bool &#123;</span><br><span class="line">		_, port, err := net.SplitHostPort(s)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return false</span><br><span class="line">		&#125;</span><br><span class="line">		return port != &quot;&quot;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if len(config.ServerPassword) == 0 &#123;</span><br><span class="line">		// only one encryption table</span><br><span class="line">		cipher, err := ss.NewCipher(config.Method, config.Password)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			log.Fatal(&quot;Failed generating ciphers:&quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line">		srvPort := strconv.Itoa(config.ServerPort)</span><br><span class="line">		srvArr := config.GetServerArray()</span><br><span class="line">		n := len(srvArr)</span><br><span class="line">		servers.srvCipher = make([]*ServerCipher, n)</span><br><span class="line"></span><br><span class="line">		for i, s := range srvArr &#123;</span><br><span class="line">			if hasPort(s) &#123;</span><br><span class="line">				log.Println(&quot;ignore server_port option for server&quot;, s)</span><br><span class="line">				servers.srvCipher[i] = &amp;ServerCipher&#123;s, cipher&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				servers.srvCipher[i] = &amp;ServerCipher&#123;net.JoinHostPort(s, srvPort), cipher&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// multiple servers</span><br><span class="line">		n := len(config.ServerPassword)</span><br><span class="line">		servers.srvCipher = make([]*ServerCipher, n)</span><br><span class="line"></span><br><span class="line">		cipherCache := make(map[string]*ss.Cipher)</span><br><span class="line">		i := 0</span><br><span class="line">		for _, serverInfo := range config.ServerPassword &#123;</span><br><span class="line">			if len(serverInfo) &lt; 2 || len(serverInfo) &gt; 3 &#123;</span><br><span class="line">				log.Fatalf(&quot;server %v syntax error\n&quot;, serverInfo)</span><br><span class="line">			&#125;</span><br><span class="line">			server := serverInfo[0]</span><br><span class="line">			passwd := serverInfo[1]</span><br><span class="line">			encmethod := &quot;&quot;</span><br><span class="line">			if len(serverInfo) == 3 &#123;</span><br><span class="line">				encmethod = serverInfo[2]</span><br><span class="line">			&#125;</span><br><span class="line">			if !hasPort(server) &#123;</span><br><span class="line">				log.Fatalf(&quot;no port for server %s\n&quot;, server)</span><br><span class="line">			&#125;</span><br><span class="line">			// Using &quot;|&quot; as delimiter is safe here, since no encryption</span><br><span class="line">			// method contains it in the name.</span><br><span class="line">			cacheKey := encmethod + &quot;|&quot; + passwd</span><br><span class="line">			cipher, ok := cipherCache[cacheKey]</span><br><span class="line">			if !ok &#123;</span><br><span class="line">				var err error</span><br><span class="line">				cipher, err = ss.NewCipher(encmethod, passwd)</span><br><span class="line">				if err != nil &#123;</span><br><span class="line">					log.Fatal(&quot;Failed generating ciphers:&quot;, err)</span><br><span class="line">				&#125;</span><br><span class="line">				cipherCache[cacheKey] = cipher</span><br><span class="line">			&#125;</span><br><span class="line">			servers.srvCipher[i] = &amp;ServerCipher&#123;server, cipher&#125;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	servers.failCnt = make([]int, len(servers.srvCipher))</span><br><span class="line">	for _, se := range servers.srvCipher &#123;</span><br><span class="line">		log.Println(&quot;available remote server&quot;, se.server)</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理服务器配置信息主要由parseServerConfig函数完成，老实说我不太喜欢这个函数，写的又臭又长看起来也很费劲，应该很有优化的空间的。<br>函数整体应该分为两个部分，用一个if分支隔离开来。if直接跟的语句负责处理单个服务器配置的信息，else跟的部分负责多个服务器配置信息的解析。整体流程如下：</p>
<p><div id="flowchart-0" class="flow-chart"></div></p>
<h4 id="开启go携程监听本地端口"><a href="#开启go携程监听本地端口" class="headerlink" title="开启go携程监听本地端口"></a>开启go携程监听本地端口</h4><p>run方法是比较简单的，使用tcp协议监听指定地址端口，采用轮询机制等待连接请求，一旦等到连接后开启一个goroutine调用 handleConnection()进行处理。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(listenAddr <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	ln, err := net.Listen(<span class="string">"tcp"</span>, listenAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">"starting local socks5 server at %v ...\n"</span>, listenAddr)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := ln.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(<span class="string">"accept:"</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> handleConnection(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##结语<br>至此，main函数的整体就差不多，接下来我们需要看下在拿到请求后，handleConnection函数是怎样对其进行处理的。</p>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start
op1=>operation: 传入服务器配置信息
cond=>condition: 是否多个配置项?
opY1=>operation: 建立ss.Cipher数组
opY2=>operation: 循环读取配置信息最后写入全局变量servers
opN1=>operation: 设置加密方法，提取ip数组
opN2=>operation: 循环设置相关信息
e=>end

st->op1->cond
cond(yes)->opY1->opY2->e
cond(no)->opN1->opN2->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/19/go版本shadowsocks源码(一)/" data-id="cjuz1npsg0001sx2xl7wwq14d" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-go语言读书笔记-action系列(方法与接口）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/11/go语言读书笔记-action系列(方法与接口）/" class="article-date">
  <time class="post-time" datetime="2019-03-11T08:07:20.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br>
    <span class="post-day">11</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/11/go语言读书笔记-action系列(方法与接口）/">go语言读书笔记-action系列(方法与接口)</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/《go语言实战》读书笔记/">《go语言实战》读书笔记</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="方法简单概述"><a href="#方法简单概述" class="headerlink" title="方法简单概述"></a>方法简单概述</h2><p>go语言中，方法是用来给用户定义的类型添加新的行为。要想给类型添加方法，只需要在函数关键字func和函数名之间加一个参数，这个参数就被称为接收者，将函数与接收者的类型绑定在一起。函数有接收者就被称为方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type user struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    email string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u user) notify() &#123;</span><br><span class="line">    fmt.Printf(&quot;hello world!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ok，其实关于这一篇读书笔记我重点想记录的是接口，关于方法大概声明就是这样，使用的套路和java、php等各种面向对象的语言都是差不多。</p>
<hr>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>go语言中的接口，个人感觉和java，php中这类相比，与实现者之间的联系真的是十分薄弱，其不需要使用任何显式的关键字指明要实现该接口。只要类型绑定了同样的方法就认为其实现了该接口，就可以赋值给该接口类型。也就是说go中需要实现某个接口不需要显式的指明实现哪一个，想实现哪个接口直接编写该方法就可以，不想实现后就删除该方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type notifier inteface &#123;</span><br><span class="line">    notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type user struct&#123;</span><br><span class="line">    name string</span><br><span class="line">    email string</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">func (u *user) notify()&#123;</span><br><span class="line">    fmt.Printf(&quot;Sending user email to %s&lt;%s&gt;\n&quot;,u.name,u.email)</span><br><span class="line">&#125;</span><br><span class="line">//这就可以说user类型实现了notifier 接口</span><br><span class="line">func main（)&#123;</span><br><span class="line">    var n notifier</span><br><span class="line">    n = user&#123;&quot;bill&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="接口的内部实现"><a href="#接口的内部实现" class="headerlink" title="接口的内部实现"></a>接口的内部实现</h2><p><img src="http://static.zybuluo.com/yiranblade/ids8bjg2xxb5yhbk7ecmoh4m/image_1d5llurtkgeq6kr1oln1gj0igdm.png" alt="image_1d5llurtkgeq6kr1oln1gj0igdm.png-126.9kB"></p>
<p>上图展示了在user类型值赋值后接口变量的值的内部布局。接口值是一个两个字长度的数据结构，第一个字包含一个指向内部表的指针。这个内部表叫iTable，包含了所存储的值的类型信息。iTable包含了已存储的值的类型信息以及与这个值相关联的一组方法。第二个字是一个指向所存储值的指针。</p>
<p><img src="http://static.zybuluo.com/yiranblade/1qecorn6y0a92pregavnwkoc/image_1d5lmui17tig1l7p1ec91bv31m4k2g.png" alt="image_1d5lmui17tig1l7p1ec91bv31m4k2g.png-128.5kB"></p>
<p>当把指针赋值给接口之后，类型信息会存储一个指向保存类型的指针，而接口值第二个字依旧保存指向实体值的指针。</p>
<hr>
<h2 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h2><p>方法集定义了接口的接受规则。当使用指针接收者来实现接口时，值类型则无法实现该接口。这是因为值类型的方法集只包括值接收者声明的方法，所以值类型无法实现指针接收者声明的方法。、</p>
<ul>
<li>以下是go语言规范里描述的方法集：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">Values</th>
<th style="text-align:center">Methods</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center">(t T)</td>
</tr>
<tr>
<td style="text-align:center">*T</td>
<td style="text-align:center">(t T) and (t *T)</td>
</tr>
</tbody>
</table>
<p><strong>T类型的值的方法集只包含值接收者声明的方法。而指向T类型的指针的方法集既包含值接收者声明的方法，也包含指针接收者声明的方法。</strong></p>
<ul>
<li>从接收者类型角度来看方法集</li>
</ul>
<table>
<thead>
<tr>
<th>Methods Receivers</th>
<th>Values</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>(t T)</td>
</tr>
<tr>
<td>*T</td>
<td>(t T) and (t *T)</td>
</tr>
</tbody>
</table>
<p>这个实际上和上面那个说的是同一件事，只不过换了个视角。如果使用指针接收者来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口。如果使用值接收者来实现一个接口，那么那个类型的值和指针都能够实现对应的接口。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇主要记录了，go中方法的简单使用以及初步了解了下接口内部的存储方式。对于接口其实我当初在看go圣经时就一直很疑惑，为什么要有值和指针方法集这种限制，为什么不可以值也传递给指针接收者。action 中也给出了回答—<strong>编译器并不是总能自动获得一个值的地址</strong>。这就好像不可能把值传递给一个行参为指针的函数一样，编译器并不总会帮我们主动获取到值的地址。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/11/go语言读书笔记-action系列(方法与接口）/" data-id="cjuz1npsx000csx2x39l113le" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go接口/">go接口</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-go语言读书笔记-action系列(类型)" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/11/go语言读书笔记-action系列(类型)/" class="article-date">
  <time class="post-time" datetime="2019-03-11T03:06:54.751Z" itemprop="datePublished">
    <span class="post-month">3月</span><br>
    <span class="post-day">11</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/11/go语言读书笔记-action系列(类型)/">go语言读书笔记-action系列(类型)</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/《go语言实战》读书笔记/">《go语言实战》读书笔记</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="用户定义的类型"><a href="#用户定义的类型" class="headerlink" title="用户定义的类型"></a>用户定义的类型</h2><p>实际上这里指的就是结构体，go语言中创建结构体的方式与c中基本大同小异，但是go会每次用上一个type 相当于给这个结构体一个命名，这一点不同于c中的用法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//go语言写法</span><br><span class="line">type user strut &#123;</span><br><span class="line">    name string</span><br><span class="line">    email string </span><br><span class="line">    ext int</span><br><span class="line">    privileged bool</span><br><span class="line">&#125;</span><br><span class="line">//c语言写法</span><br><span class="line">struct user &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    char *email;</span><br><span class="line">    int ext;</span><br><span class="line">    bool privileged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然c也可以用typedef这个关键字 给予别名使用。</p>
<p>但是go中的type 定义的类型会被认定为一个新的类型，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type blade int</span><br></pre></td></tr></table></figure></p>
<p>这个blade会被认为是全新的类型，将int类型赋值给它时会报错，c语言中就仅仅只是个别名的意思，赋值依然可以。</p>
<p>##内置类型<br>内置类型指的就是数值类型、字符串类型和布尔类型，也就是常说的int，string这类的。因为其是原始类型，所以对其进行增加或者删除都会创建新值，因为其底层结构不共享。<br>action中举了这样一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func Trim(s string, cutset string) string&#123;</span><br><span class="line">    if s == &quot;&quot; || cutset == &quot;&quot;nc&#123;</span><br><span class="line">        return s</span><br><span class="line">    &#125;</span><br><span class="line">    return TrimFunc(s,makeCutsetFunc(cutset))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数对调用者原始的string值的一个副本进行操作，并且返回一个新的string值做副本。字符串就像整数、浮点数和布尔值一样，本质上是一种很原始的数据值，所以在函数或方法内外传递时，要传递字符串的一份副本。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>go语言中的引用类型有：切片、映射、通道、接口、和函数类型。创建上述类型的变量是共享底层数据结构的。<br>�由于其底层共享结构，所以不需要通过指针来共享引用类型的值，而通过复制来传递引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (ip IP) MarshalText() ([]byte,error)&#123;</span><br><span class="line">    if len(ip) == 0&#123;</span><br><span class="line">        return []byte(&quot;&quot;),nil</span><br><span class="line">    &#125;</span><br><span class="line">    if len(ip) != IPV4len &amp;&amp; len(ip) !=IPv6len&#123;</span><br><span class="line">        return nil,erroes.New(&quot;invalid IP address&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return []byte(ip.String()),nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码，正如预期的那样通过复制来传递引用，从而不需要通过指针来共享引用类型的值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>go语言中的类型大体上就分为这几类，在其作为方法的参数时，创建新的值就用值接收者，否则就用指针。这就是保持传递的一致性。内置类型与引用类型传递的时候，就需要把握其特性再根据传递原则决定如何使用，比如引用类型因为其底层共享结构，就不用传递指针，仅仅传递引用的副本就可以完成修改值的操作，而内置类型就需要指针。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/11/go语言读书笔记-action系列(类型)/" data-id="cjuz1npsy000esx2xj7a2y8ym" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go数据类型/">go数据类型</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-go语言读书笔记-action系列（映射）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/01/go语言读书笔记-action系列（映射）/" class="article-date">
  <time class="post-time" datetime="2019-03-01T06:43:32.361Z" itemprop="datePublished">
    <span class="post-month">3月</span><br>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/01/go语言读书笔记-action系列（映射）/">go语言读书笔记-action系列（映射）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/《go语言实战》读书笔记/">《go语言实战》读书笔记</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于习惯了map这种表述方式的我，现在看来还是go中使用映射这个词，表达这一结构感觉更加精准点。</p>
<h2 id="映射内部实现方式"><a href="#映射内部实现方式" class="headerlink" title="映射内部实现方式"></a>映射内部实现方式</h2><p>映射的内部是无序的，因为其使用了散列表。<br><img src="http://static.zybuluo.com/yiranblade/f73al21v28v8ixnbx7b09813/image_1d4rk5af2rkt1taiego1ied6jv9.png" alt="image_1d4rk5af2rkt1taiego1ied6jv9.png-156.1kB"></p>
<p>映射的散列结构包含一组桶，所有的操作都要先选择一个桶。把操作映射时指定的键传递给映射的散列函数就可以选中对应的桶。<br>go语言生成散列键的过程如下：</p>
<ol>
<li>这些字符串会转换为一个数值（散列值）。</li>
<li>这个数值落在映射已有桶的序号范围内表示一个可以用于存储的桶的序号。</li>
<li>最后这个数值被用来选择桶，用于存储或者查找指定的键值对。</li>
</ol>
<p>在此需要强调的是，散列值的低位用来选择桶，高位用来区分不同的项。<br>对于桶的内部实现，感觉action中解释的并不是很好，尤其这个散列值高位的作用，解释感觉很难理解。<br>桶的内部实现使用两个数据结构实现。第一个是数组，内部存储的是用于选择桶的散列键的高位值（在对key/value对增删查的时候，先比较key的hash值高八位是否相等，然后再比较具体的key值，主要用来帮助区分寻找对应的key，不用每次都对key做全等判断）。第二个数据结构是一个字节数组，用于存储键值对。该字节数组存储了这个桶里所有的键，之后依次存储了这个桶里所有的值。</p>
<h2 id="映射的扩容"><a href="#映射的扩容" class="headerlink" title="映射的扩容"></a>映射的扩容</h2><p>action没有提到这一点，但是我觉得应该去探索下。<br>在桶中插入元素时，当桶填满后，将通过overflow指针来mallocgc一个新的bucket出来形成链表。<br>随着元素的增长，在桶链中寻找特定的key会变得效率低下，所以再插入的元素个数/桶达到阙值时（貌似设置为6.5），map会扩容，创建新的桶数组，长度为之前长度的两倍。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/01/go语言读书笔记-action系列（映射）/" data-id="cjuz1nptb000wsx2xrxwfhd3p" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go映射/">go映射</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">next &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">yiranblade&#39;s blog</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author"></h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>14</strong><br>文章</div></a>
      <a href="/categories"><div><strong>5</strong><br>分类</div></a>
      <a href="/tags"><div><strong>10</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/yiranblade" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="http://blog.yiranblade.cn/" target="_blank" title="ShanaMaid">
          ShanaMaid
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2018 - 2019 yiranblade&#39;s blog<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>

    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>

<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title class="menuItem">首页</a>
          
            <a href="/tags" title class="menuItem">标签</a>
          
            <a href="/categories" title class="menuItem">分类</a>
          
            <a href="/archives" title class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>







  </div>
</body>
</html>