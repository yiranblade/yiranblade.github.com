<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>yiranblade&#39;s blog</title>
  <meta name="description" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" />

  <meta name="generator" content="yiranblade's blog">

  
  
  

  
</head>


<body class="post-template">

  <header class="site-head" style="background-image: url(//github.com/yiranblade/yiranblade.github.io/blob/master/image/miao1.jpg?raw=true)">
    <div class="vertical">
        <div class="site-head-content inner">
             <a class="blog-logo" href="/"><img src="//timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1550662707158&di=cbe3e6f18206a4d6f1e7bbd1b8fb2d81&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201408%2F29%2F20140829092016_cvJRe.jpeg" alt="Blog Logo"></a> 
            <h1 class="blog-title">yiranblade's blog</h1>
            <h2 class="blog-description"></h2>
        </div>
    </div>
</header>
  

<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
      <time datetime="2019-02-21T09:07:11.121Z" itemprop="datePublished">
          2019-02-21
      </time>
    
</span>
    <h1 class="post-title"></h1>
    <section class="post-content">
      <h1 id="go语言读书笔记之反射"><a href="#go语言读书笔记之反射" class="headerlink" title="go语言读书笔记之反射"></a>go语言读书笔记之反射</h1><hr>
<p>能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道这些变量的具体类型。这种机制被称为反射。go语言中对于反射的定义与java中并无太大差别，基本核心都是在运行时更新变量调用方法之类的。<br>换句话说就是反射允许在编译期间不知道变量或者接口的名称，字段、方法，值的情况下在运行时检查类、接口字段和方法以及他们的值。</p>
<h2 id="go中的反射"><a href="#go中的反射" class="headerlink" title="go中的反射"></a>go中的反射</h2><p>go中的反射主要由reflect包来提供。其定义两个比较重要的类型，Type与Value，一个type表示一个go类型。<br>其拥有一个函数typeof,该函数接受人意的interface{}类型，并以reflect.Type形式返回动态类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := reflext.Typeof(3)</span><br></pre></td></tr></table></figure></p>
<p>在调用typeof函数的过程中，其会将一个具体的值转换为接口类型，并且拥有一个隐式的接口转换操作，创建包含两个信息的接口值：操作数的动态类型和其动态值。<br>em…还有一个比较重要的类型是刚才说到的Value，函数reflect.ValueOf接受任意的interface{}类型，并返回一个装载着其动态值的reflexct.Value和reflect.TypeOf类似，reflect。.ValueOf返回的结构也是具体的类型，但是reflect.Value也可以持有一个接口值.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := reflect.ValueOf(3)</span><br></pre></td></tr></table></figure></p>
<h2 id="go反射原理"><a href="#go反射原理" class="headerlink" title="go反射原理"></a>go反射原理</h2><p>无意中在网上好多blog看到一个概念，go语言的三大反射定律，查了半天也没找到出处，但是总结的还是可以的，了解后对于go的反射机制应该说可以有一个总的了解，使用起来也简单很多。</p>
<ul>
<li>Reflection goes from interface value to reflection object（从接口值映射到反射对象）<ul>
<li>这一点感觉很好理解：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:=<span class="number">5</span></span><br><span class="line">b:=reflect.ValueOf(a)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>调用valueOf方法时，go语言这里会对a进行一个隐式的接口转换操作，�且创建一个包含两个信息的接口值：操作数的动态类型(int)和其动态的值（这里是5）。随后其会返回一个value的对象。
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ValueOf returns a new Value initialized to the concrete value</span></span><br><span class="line"><span class="comment">// stored in the interface i. ValueOf(nil) returns the zero Value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Maybe allow contents of a Value to live on the stack.</span></span><br><span class="line">	<span class="comment">// For now we make the contents always escape to the heap. It</span></span><br><span class="line">	<span class="comment">// makes life easier in a few places (see chanrecv/mapassign</span></span><br><span class="line">	<span class="comment">// comment below).</span></span><br><span class="line">	escapes(i)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在value对象中包含了该变量的动态类型描述信息，指向其值的指针类型，以及一个检测值是否支持某些操作的flag。
利用value对象，valueOf的调用者，即可进行进一步操作，获取值，类型信息，修改变量值等等。这个value就是第一反射定律里指的`reflection object`,typeOf()方法同理。
</code></pre><hr>
<ul>
<li><p>Reflection goes from reflection object to interface value( 从反射对象映射到接口值)</p>
<ul>
<li><p>这句话顾名思义，是前一个定律的逆</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := b.Interface()</span><br></pre></td></tr></table></figure>
<p>调用之前的b这个Value对象的Interface方法，其内部执行过程如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Interface returns v's current value as an interface&#123;&#125;.</span></span><br><span class="line"><span class="comment">// It is equivalent to:</span></span><br><span class="line"><span class="comment">//	var i interface&#123;&#125; = (v's underlying value)</span></span><br><span class="line"><span class="comment">// It panics if the Value was obtained by accessing</span></span><br><span class="line"><span class="comment">// unexported struct fields.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Interface</span><span class="params">()</span> <span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> valueInterface(v, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>可以看到其将value又转换回接受任意的interface{}类型，打印一下其结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   a := 5</span><br><span class="line">b := reflect.ValueOf(a)</span><br><span class="line">c := b.Interface()</span><br><span class="line">fmt.Println(c)</span><br><span class="line">//5</span><br></pre></td></tr></table></figure></p>
<p>综上来看，Interface方法就是Valueof方法的逆，返回值是interface{}，网上看到这样一句话：反射就是从接口值到反射对象，然后再反射回来。</p>
<hr>
<ul>
<li>To modify a reflection object, the value must be settable（为了修改一个反射对象，修改的值必须是settable）</li>
</ul>
<p>有时候会需要修改反射对象的值，但是直接reflect.ValueOf出来的是不可取地址的，可以被修改的变量称为settable，即可取地址。如果需要从变量中取到可取地址的value需要这么做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x := 2</span><br><span class="line">d := reflect.ValueOf(&amp;x).Elem()   // d refers to the variable x</span><br><span class="line">px := d.Addr().Interface().(*int) // px := &amp;x</span><br><span class="line">*px = 3                           // x = 3</span><br><span class="line">fmt.Println(x)   </span><br><span class="line">//另一种做法是</span><br><span class="line">d.Set(reflect.ValueOf(8))</span><br></pre></td></tr></table></figure></p>
<p>之所以不可以直接修改反射对象的值，是因为直接reflect.Valueof的值仅仅只是变量的一个副本，对其进行操作是无法修改变量本身的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于go中的反射，这里探讨的还是比较基础的，但是整体用法无外乎这些，剩下的就是具体对于调用方法与函数，map以及slices等的使用，本质上的结构还是不会有太大变化的，比如结构体使用实际上就是用同样的方法去访问其中的每个域。最后对于反射这一特性，《go程序设计语言》在反射一章的最后认为应该被谨慎小心的使用，原因主要有以下三点：</p>
<ol>
<li>基于反射的代码是比较脆弱的。如果误用，编译器不会马上报错，在运行阶段造成的错误很可能是比较致命的。</li>
<li>反射的操作由于无法做静态类型检查，大量的反射代码难以理解。</li>
<li>反射代码比正常代码运行速度慢。</li>
</ol>

    </section>
    <footer class="post-footer">
      <section class="author">
    <h4></h4>
    <p></p>
</section>
      <section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" href="http://twitter.com/share?url=http://yoursite.com/2019/02/21/go语言读书笔记之反射/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/02/21/go语言读书笔记之反射/" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" href="https://plus.google.com/share?url=http://yoursite.com/2019/02/21/go语言读书笔记之反射/" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
</section>
    </footer>
  </article>
  <nav class="pagination" role="pagination">
    
    <span class="page-number">•</span>
    
</nav>
  <div id="comment" class="comments-area">
    <h1 class="title"><a href="#disqus_comments" name="disqus_comments">Comments</a></h1>

    
</div>
</main>


  
<footer class="site-footer">
  
  <div class="inner">
     <section class="copyright">All content copyright <a href="/">yiranblade's blog</a> &copy; 2014 &bull; All rights reserved.</section>
     <section class="poweredby">Proudly published with <a class="icon-ghost" href="http://zespia.tw/hexo/">Hexo</a></section>
  </div>
</footer>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>






</body>
</html>
